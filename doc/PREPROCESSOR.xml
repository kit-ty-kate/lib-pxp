<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE readme SYSTEM "readme.dtd" [
 
<!ENTITY % common SYSTEM "common.xml">
%common;
 
<!ENTITY m "<em>PXP</em>">
 
]>
 
<readme title="The Preprocessor for PXP">
  <sect1>
    <title>The Preprocessor for PXP</title>

    <p>Since PXP-1.1.95, there is a preprocessor as part of the PXP
distribution. It allows you to compose XML trees and event lists
dynamically, which is very handy to write XML transformations.</p>

    <p>To enable the preprocessor, compile your source files as in:

<code>
ocamlfind ocamlc -syntax camlp4o -package pxp-pp,... ...
</code>

The package pxp-pp contains the preprocessor. The -syntax option
enables camlp4, on which the preprocessor is based. It is also
possible to use it together with the revised syntax, use
"-syntax camlp4r" in this case.</p>

    <p>In the toploop, type

<code>
ocaml
# #use "topfind";;
# #camlp4o;;
# #require "pxp-pp";;
# #require "pxp";;
</code>
</p>

    <p>The preprocessor defines the following new syntax notations,
explained below in detail:

<code><![CDATA[
<:pxp_charset< CHARSET_DECL >>
<:pxp_tree< EXPR >>
<:pxp_vtree< EXPR >>
<:pxp_evlist< EXPR >>
<:pxp_evpull< EXPR >>
<:pxp_text< TEXT >>
]]></code>

The basic notation is "pxp_tree" which creates a tree of PXP document
nodes as described in EXPR. "pxp_vtree" is the variant where the tree
is immediately validated. "pxp_evlist" creates a list of PXP events
instead of nodes, useful together with the event-based parser.
"pxp_evpull" is a variation of the latter: Instead of an event list
an event generator is created that works like a pull parser.</p>

<p>The "pxp_charset" notation only configures the character sets to
assume. Finally, "pxp_text" is a notation for string literals.</p>

    <sect2>
      <title>Creating constant XML</title>

<p>The following examples are all written for "pxp_tree". You can
also use one of the other XML composers instead, but see the notes
below.</p>

<p>In order to use "pxp_tree", you must define two variables in 
the environment: "spec" and "dtd":

<code>
let spec = Pxp_tree_parser.default_spec;;
let dtd = Pxp_dtd.create_dtd `Enc_iso88591;;
</code>

These variables occur in the code generated by the preprocessor.
The "dtd" variable is the DTD object. Note that you need it even
in well-formedness mode (validation turned off). The "spec" variable
controls which classes are instantiated as node representation
(see PXP manual).</p>

<p>Now you can create XML trees like in

<code><![CDATA[
let book = 
  <:pxp_tree< 
    <book>
      [ <title>[ "The Lord of The Rings" ]
        <author>[ "J.R.R. Tolkien" ]
      ]
  >>
]]></code>

As you can see, the syntax is somehow XML-related but not really XML.
(Many ideas are borrowed from CDUCE, by the way.) In particular,
there are start tags like &lt;title&gt; but no end tags. Instead,
we are using square brackets to denote the children of an XML
element. Furthermore, character data must be put into double
quotes.</p>

<p>You may ask why the well-known XML syntax has been modified for
this preprocessor. There are many reasons, and they will become
clearer in the following explanations. For now, you can see the advantage
that the syntax is less verbose, as you need not to repeat the
element names in end tags. Furthermore, you can exactly control
which characters are part of the data nodes without having to make
compromises with indentation.</p>

<p>Attributes are written as in XML:

<code><![CDATA[
let book = 
  <:pxp_tree< 
    <book id="BOOK_001">
      [ <title lang="en">[ "The Lord of The Rings" ]
        <author>[ "J.R.R. Tolkien" ]
      ]
  >>
]]></code>
</p>

<p>An element without children can be written

<code><![CDATA[
<element>[]
]]></code>

or slightly shorter:

<code><![CDATA[
<element/>
]]></code>
      </p>
<p>You can also create processing instructions and comment nodes:

<code><![CDATA[
let list =
  <:pxp_tree<
    <list>
      [ <!>"Now the list of books follows!"
        <?>"formatter_directive" "one book per page"
        book
      ]
 >>
]]></code>

The notation "&lt;!>" creates a comment node with the following string
as contents. The notation "&lt;?>" needs two strings, first the target,
then the value (here, this results in
"&lt;?formatter_directive one book per page?>". </p>

<p>Look again at the last example: The O'Caml variable "book" occurs,
and it inserts its tree into the list of books. Identifiers
without "decoration" just refer to O'Caml variables. We will see
more examples below.</p>

<p>The preprocessor syntax knows a number of shortcuts and variations.
First, you can omit the square brackets when an element has exactly
one child:

<code><![CDATA[
<element><child>"Data inside child"
]]></code>

This is the same as

<code><![CDATA[
<element>[ <child>[ "Data inside child" ] ]
]]></code>

Second, you are already used to a common abbreviation: Strings are 
automatically converted to data nodes. The "expanded" syntax is

<code><![CDATA[
<*>"Data string"
]]></code>

where "&lt;*>" denotes a data node, and the following string is
used as contents. Usually, you can omit "&lt;*>". However, there
are a few occasions where this notation is still useful, see below.</p>

<p>In strings, the usual entity references can be used:
"Double quotes: &amp;quot;". For a newline character,
write &amp;#10;.</p>

<p>The preprocessor knows two operators: "^" concatenates strings,
and "@" concatenates lists. Examples:

<code><![CDATA[
<element>[ "Word1" ^ "Word2" ]
<element>([ <a/> ] @ [ <b/> ])
]]></code></p>

<p>Parentheses can be used to clarify precedence. For example:

<code><![CDATA[
<element>(l1 @ l2)
]]></code>

Here, the concatenation operator "@" could also be parsed as

<code><![CDATA[
(<element> l1) @ l2
]]></code>

Parentheses may be used in every expression.</p>

      <p>Rarely used, there is also a notation for the
"super root" nodes (see the PXP manual for their meaning):

<code><![CDATA[
<^>[ <element> ... ]
]]></code>
      </p>

    </sect2>


    <sect2>
      <title>Dynamic XML</title>

      <p>Let us begin with an example. The task is to convert
O'Caml values of type

<code><![CDATA[
type book = 
  { title : string;
    author : string;
    isbn : string;
  }
]]></code>

to XML trees like

<code><![CDATA[
<book id="BOOK_'isbn'">
  <title>'title'</title>
  <author>'author'</title>
</book>
]]></code>

(conventional syntax). When b is the book variable, the solution is

<code><![CDATA[
let book = 
  let title = b.title
  and author = b.author
  and isbn = b.isbn in
  <:pxp_tree<
    <book id=("BOOK_" ^ isbn)>
      [ <title><*>title
        <author><*>author
      ]
  >>
]]></code>

First, we bind the simple O'Caml variables "title", "author", and
"isbn". The reason is that the preprocessor syntax does not allow
expressions like "b.title" directly in the XML tree (but see below
for a better workaround).</p>

<p>The XML tree contains the O'Caml variables. The "id" attribute
is a concatenation of the fixed prefix "BOOK_" and the contents of
"isbn". The "title" and "author" elements contain a data node
whose contents are the O'Caml strings "title", and "author",
respectively.</p>

<p>Why "&lt;*>"? If we just wrote "&lt;title>title", the
generated code would assume that the "title" variable is an XML node,
and not a string. From this point of view, "&lt;*>" works like
a type annotation, as it specialises the type of the following
expression.</p>
        
<p>Here is an alternate solution:

<code><![CDATA[
let book = 
  <:pxp_tree<
    <book id=("BOOK_" ^ (: b.isbn :))>
      [ <title><*>(: b.title :)
        <author><*>(: b.author :)
      ]
  >>
]]></code>

The notation "(: ... :)" allows you to include arbitrary O'Caml
expressions into the tree. In this solution it is no longer necessary
to create artificial O'Caml variables for the only purpose of
injecting values into trees.
      </p>

      <p>It is possible to create XML elements with dynamic names:
Just put parentheses around the expression. Example:

<code><![CDATA[
let name = "book" in
<:pxp_tree< <(name)> ... >>
]]></code>

With the same notation, one can also set attribute names dynamically:

<code><![CDATA[
let att_name = "id" in
<:pxp_tree< <book (att_name)=...> ... >>
]]></code>

Finally, it is also possible to include complete attribute lists
dynamically:

<code><![CDATA[
let att_list = [ "id", ("BOOK_" ^ b.isbn) ] in
<:pxp_tree< <book (: att_list :) > ... >>
]]></code>
      </p>

<p>Typing: Depending on where a variable or O'Caml expression occurs,
different types are assumed. Compare the following examples:

<code><![CDATA[
<:pxp_tree< <element>x1 >>
<:pxp_tree< <element>[x2] >>
<:pxp_tree< <element><*>x3 >>
]]></code>

As a rule of thumb, the most general type is assumed that would make
sense at a certain location. As x1 could be replaced by a list
of children, its type is assumed to be a node list. As x2 could
be replaced by a single node, its type is assumed to be a node.
And x3 is a string, we had this case already.
</p>
    </sect2>

    <sect2>
      <title>Character Encodings</title>

      <p>As the preprocessor generates code that builds XML trees, it
must know two character encodings:</p>

<ul>
	<li><p>Which encoding is used in the source code (in the .ml file)
</p></li>
	<li><p>Which encoding is used in the XML representation, i.e.
in the O'Caml values representing the XML trees</p></li>
</ul>

<p>Both encodings can be set independently. The syntax is:

<code><![CDATA[
<:pxp_charset< source="ENC" representation="ENC" >>
]]></code>

The default is ISO-8859-1 for both encodings. For example, to set
the representation encoding to UTF-8, use:

<code><![CDATA[
<:pxp_charset< representation="UTF-8" >>
]]></code>

The "pxp_charset" notation is a constant expression that always
evaluates to "()". (A requirement by camlp4 that looks artificial.)
</p>

<p>When you set the representation encoding, it is required that the
encoding stored in the DTD object is the same. Remember that we
need a DTD object like

<code>
let dtd = Pxp_dtd.create_dtd `Enc_iso88591;;
</code>

Of course, we must change this to the representation encoding, too,
in our example:

<code>
let dtd = Pxp_dtd.create_dtd `Enc_utf8;;
</code>

The preprocessor cannot check this at compile time, and for performance
reasons, a runtime check is not generated. So it is up to the programmer
that the character encodings are used in a consistent way.
</p>
    </sect2>


    <sect2>
      <title>Validated Trees</title>

      <p>In order to validate trees, you need a filled DTD object.
In principle, you can create this object by a number of methods.
For example, you can parse an external file:

<code><![CDATA[
let dtd = Pxp_dtd_parser.parse_dtd_entity config (from_file "sample.dtd")
]]></code>

It is, however, often more convenient to include the DTD literally
into the program. This works by

<code><![CDATA[
let dtd = Pxp_dtd_parser.parse_dtd_entity config (from_string "...")
]]></code>

As the double quotes are often used inside DTDs, O'Caml string
literals are a bit impractical, as they are also delimited by
double quotes, and one needs to add backslashes as escape characters.
The "pxp_text" notation is often more readable here:
&lt;:pxp_text&lt;STRING>> is just another way of writing
"STRING". In our DTD, we have

<code><![CDATA[
let dtd_text =
  <:pxp_text<
    <!ELEMENT book (title,author)>
    <!ATTLIST book id CDATA #REQUIRED>
    <!ELEMENT title (#PCDATA)>
    <!ATTLIST title lang CDATA "en">
    <!ELEMENT author (#PCDATA)>
  >>;;
let config = default_config;;
let dtd = Pxp_dtd_parser.parse_dtd_entity config (from_string dtd_text);;
]]></code>

Note that "pxp_text" is not restricted to DTDs, as it can be used
for any kind of string.</p>

      <p>After we have the DTD, we can validate the trees. One
option is to call the "validate" function:

<code><![CDATA[
let book = 
  <:pxp_tree< 
    <book>
      [ <title>[ "The Lord of The Rings" ]
        <author>[ "J.R.R. Tolkien" ]
      ]
  >>;;
Pxp_document.validate book;;
]]></code>

(This example is invalid, as the "id" attribute is missing.)</p>

<p>Note that it is a misunderstanding that "pxp_tree" builds XML trees in
well-formed mode. You can create any tree with it, and the fact is that
"pxp_tree" just does not invoke the validator. So if the DTD enforces
validation, the tree is validated when the "validate" function is
called. If the DTD is in well-formedness mode, the tree is effectively
not validated, even when the "validate" function is invoked. Btw,
the following statements would create a DTD in well-formedness mode:

<code>
let dtd = Pxp_dtd.create_dtd `Enc_iso88591;;
dtd # allow_arbitrary;
</code>

As an alternative of calling the "validate" function, one can also
use "pxp_vtree" instead. It immediately validates every XML element it
creates. However, "injected" subtrees are not validated, i.e. validation
does not proceed recursively to subnodes as the "validate" function
does it.</p>
    </sect2>


    <sect2>
      <title>Generating Events</title>

      <p>As PXP has also an event model to represent XML, the preprocessor
can also produce such events. In particular, there are two modes: The
"pxp_evlist" notation outputs lists of events (type "event list")
representing the XML expression. The "pxp_evpull" notation creates
an automaton from which one can "pull" events (like from a pull
parser).</p>

      <p>These two notations work very much like "pxp_tree". For example,

<code><![CDATA[
let book = 
  <:pxp_evlist< 
    <book>
      [ <title>[ "The Lord of The Rings" ]
        <author>[ "J.R.R. Tolkien" ]
      ]
  >>
]]></code>

generates 

<code><![CDATA[
[ E_start_tag ("book", [], None, <obj>);
  E_start_tag ("title", [], None, <obj>);
  E_char_data "The Lord of The Rings"; 
  E_end_tag ("title", <obj>);
  E_start_tag ("author", [], None, <obj>); 
  E_char_data "J.R.R. Tolkien";
  E_end_tag ("author", <obj>); 
  E_end_tag ("book", <obj>)
]
]]></code>

Note that you neither need a "dtd" variable nor a "spec" variable.
There is one important difference, however: Both nodes and lists
of nodes are represented by the same type, "event list". That
has the consequence that in the following example x1 and x2
have the same type "event list":

<code><![CDATA[
<:pxp_evlist< <element>x1 >>
<:pxp_evlist< <element>[x2] >>
<:pxp_evlist< <element><*>x3 >>
]]></code>

In principle, it could be checked at runtime whether x1 and x2
have the right structure. However, this is not done because of
performance reasons.</p>

      <p>As mentioned, "pxp_evpull" works like a pull parser.
After defining

<code><![CDATA[
let book = 
  <:pxp_evpull< 
    <book>
      [ <title>[ "The Lord of The Rings" ]
        <author>[ "J.R.R. Tolkien" ]
      ]
  >>
]]></code>

"book" is a function 'a->event. One can call it to get the events
one after the other:

<code><![CDATA[
let e1 = book();;       (* = Some(E_start_tag ("book", [], None, <obj>)) *)
let e2 = book();;       (* = Some(E_start_tag ("title", [], None, <obj>)) *)
...
]]></code>

After the last event, "book" returns None to indicate the end of the
event stream.</p>

      <p>As for "pxp_evlist", it is not possible to distinguish between
nodes and node lists. In this example, both x1 and x2 are assumed
to have type 'a->event:

<code><![CDATA[
<:pxp_evlist< <element>x1 >>
<:pxp_evlist< <element>[x2] >>
<:pxp_evlist< <element><*>x3 >>
]]></code>

Note that "&lt;element>x1" actually means to build a new pull automaton
around the existing pull automaton x1: The children of "element" are
retrieved by pulling events from x1 until "None" is returned.</p>

      <p>A consequence of the pull semantics is that once an event
is obtained from an automaton, the state of the automaton is modified
such that it is not possible to get the same event again. If you need
an automaton that can be reset to the beginning, just wrap the
"pxp_evlist" notation into a functional abstraction:

<code><![CDATA[
let book_maker() =
  <:pxp_evpull< <book ...> ... >>;;
let book1 = book_maker();;
let book2 = book_maker();;
]]></code>

This way, "book1" and "book2" are independent event streams.</p>

      <p>There is another implication of the nature of the
automatons: Subexpressions are lazily evaluated. For example,
in

<code><![CDATA[
<:pxp_evpull< <element>[ <*> (: get_data_contents() :) ] >>
]]></code>

the call of get_data_contents is performed just before the event
for the data node is constructed.</p>
    </sect2>


    <sect2>
      <title>Namespaces</title>

      <p>By default, the preprocessor does not generate nodes or
events that support namespaces. It can, however, be configured
to create namespace-aware XML aggregations.
      </p>

      <p>In any case, you need a namespace manager. This is an object
that tracks the usage of namespace prefixes in XML nodes. For example,
we can create a namespace manager that knows the "html" prefix:

<code><![CDATA[
let mng = new namespace_manager in
mng # add_namespace "html" "http://www.w3.org/1999/xhtml"
]]></code>

Here, we declare that we want to use the "html" prefix for the
internal representation of the XML nodes. This kind of prefix is
called normalized prefix, or normprefix for short. It is possible to configure
different prefixes for the external representation, i.e. when the
XML tree is printed to a file. This other kind of prefix is called
display prefix. We will have a look at them later.</p>

<p>Next, we must tell the DTD object that we have a namespace manager:

<code><![CDATA[
let dtd = Pxp_dtd.create_dtd `Enc_iso88591;;
dtd # set_namespace_manager mng;;
]]></code>
      </p>

<p>For "pxp_evlist" and "pxp_evpull" we are now prepared (note that
we need now a "dtd" variable, as the DTD object knows the namespace
manager). For "pxp_tree" and "pxp_vtree", it is required to use
a namespace-aware specification:

<code><![CDATA[
let spec = Pxp_tree_parser.default_namespace_spec 
]]></code>

(Normal specifications do not work, you would get "Namespace method
not applicable" errors if you tried to use them.)</p>

<p>The special notation "&lt;:autoscope>" enables namespace mode in 
this example:

<code><![CDATA[
let list =
  <:pxp_tree<
    <:autoscope>
      <html:ul>
        [ <html:li>"Item1"
          <html:li>"Item2"
        ]
  >>
]]></code>

In particular, "&lt;:autoscope>" defines a new O'Caml variable for
its subexpression: "scope". This variable contains the namespace
scope object, which contains the namespace declarations for the
subexpression. "&lt;:autoscope>" initialises this variable from the
namespace manager such that it contains now a declaration for the
"html" prefix.</p>

<p>In general, the namespace scope object contains the prefixes to use for the
external representation. For this simple example, we have chosen
to use the same prefixes as for the internal representation,
and "&lt;:autoscope>" performs the right initialisations for this.</p>

<p>Print the tree by 

<code><![CDATA[
list # display (`Out_channel stdout) `Enc_iso88591
]]></code>

The point is to call the "display" method and not the "write" method.
The latter would not respect the display prefixes.
      </p>

<p>Alternatively, we can also create the "scope" variable manually:

<code><![CDATA[
let scope = Pxp_dtd.create_namespace_scope
              ~decl:[ "", "http://www.w3.org/1999/xhtml" ]
              mng;;
let list =
  <:pxp_tree<
    <:scope>
      <html:ul>
        [ <html:li>"Item1"
          <html:li>"Item2"
        ]
  >>
]]></code>

Note that we now use "&lt;:scope>". In this simple form, this
construct just enables namespace mode, and takes the "scope"
variable from the environment.</p>

<p>Furthermore, the namespace scope contains now a different
namespace declaration: The display prefix "" is used for HTML. The
empty prefix just means to declare a default prefix
(by xmlns="URI"). The effect can be seen when the XML tree 
is printed by calling the "display" method.</p>

<p>Here is a third variant of the same example:

<code><![CDATA[
let scope = Pxp_dtd.create_namespace_scope mng ;;
let list =
  <:pxp_tree<
    <:scope ("")="http://www.w3.org/1999/xhtml">
      <html:ul>
        [ <html:li>"Item1"
          <html:li>"Item2"
        ]
  >>
]]></code>

The "scope" is now initially empty. The "&lt;:scope>" notation is
used to extend the scope for the time the subexpression is 
evaluated.</p>

      <p>There is also a notation "&lt;:emptyscope" that creates
an empty scope object, so one could even write

<code><![CDATA[
let list =
  <:pxp_tree<
    <:emptyscope>
      <:scope ("")="http://www.w3.org/1999/xhtml">
	<html:ul>
	  [ <html:li>"Item1"
	    <html:li>"Item2"
	  ]
  >>
]]></code>
      </p>

<p>It is recommended to create the "scope" variable manually with
a reasonable initial declaration, and to use "&lt;:scope>" to
enable namespace processing, and to extend the scope when necessary.
The advantage of this approach is that the same scope object can be
shared by many XML nodes, so you need less memory.</p>

<p>One tip: To get a namespace scope that is initialised with all
prefixes of the namespace manager (as &lt;:autoscope> does it), define

<code>
let scope = create_namespace_scope ~decl: mng#as_declaration mng
</code>
      </p>

<p>For event-based processing of XML, the namespace mode works in
the same way as described here, there is no difference.</p>
    </sect2>

  </sect1>
</readme>


