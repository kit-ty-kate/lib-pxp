- Event-based parsers:

  * Parse a single element, PI, comment, ... instead of misc* element misc*

  * process_entity: erstes Token kann übergeben werden

    Letztes Token?

  * { and } inside attribute lists DONE
    
    TODO: Don't forget: pxp_lex_content_string.src: more efficient way of
    handling character sequences

  * Check: standalone flag

  * Signature for entity_manager

  * Examples

  * Pull parser

    Parse a single tag!

- Follow-Ups:

  * Clean-Up of pxp_yacc.m2y: separate tree_parser and event_parser.
    They have a common superclass where event methods are virtual.

  * extend_dtd: export?

    process_entity kann im wf-Modus oder im validating-Modus aufgerufen
    werden. dies hat aber nur Einfluss auf die konstruktion der DTD.

  * standalone

  * Clean-Up of Pxp_entity. At least define class type entity (in .ml).

  * Entry point document: hat einen Parameter, der definiert, wie mit
    DTDs umgegangen werden soll.
    type dtd_mode = [ `Only_entities | `Full ]

  * Pxp_light: XML-Baum als rekursiver Typ
    Pxp_light_trans: Light-Darstellung von/nach Heavy-Darstellung konvertieren
    Pxp_light_docemu: Light-Darstellung als Document-kompatible Klasse

- Improvements:

  * Clone nodes and change DTD

  * parse_wfdocument_entity: argument ~share_dtd

------------------------------

- Klasse wfdocument

------------------------------

- Pxp_lexing: fast_from_function programmieren, das direkt den lexbuf
  benutzt.

- Pxp_dtd.Entity: get_resolver

- Pxp_entity: method copy (relocate)

- Pxp_marshal.relocate_document: copy the entities, too

- Resolvers: get_base_uri

------------------------------

- Separate well-formed documents from validated documents
  + Generalize DTDs so that schemas can be implemented

- PXP 1.2: Adapter to Nethtml: Parses HTML and converts it to a PXP object
  tree.

  ==> module Pxp_html

- PXP 1.2: embedded XML (see below)

- PXP 1.2: XPATH

  ==> module Pxp_xpath definiert XPATH-Kernfunktionen

- PXP 1.2: Adapter to Netclient

Problems with Pxp_reader: there should be some notion of "relative URI"
vs. "absolute URI". Currently, processing of relative URIs works only
if the active resolver always accepts relative URIs. I.e. it works but
is error-prone.
Idea: open_in has new argument ~scheme:
  - Some "http":    The URI is absolute
  - Some "":        The URI is empty, or Private, or Anonymous
  - None:           The URI is relative
'combine' would interpret the rejection of a relative URI as an error.

Pxp_reader: Perhaps a Redirection exception could be useful.
See netclient.

Pxp_document: The representation of the children list needs to be
improved. Perhaps a balanced tree would work well that allows accesses
by index.

----------------------------------------------------------------------

- E-XML:

  <dtd< dtd material >>

  <element< xml material >>  --> transformiert in eine FUNKTION, die mit
	create_xxx den Term zusammenbaut. Mittels $-Notation läßt sich angeben,
        welche (benannten) Argumente die Funktion hat.

  <data< text material >>

  spec, dtd: aus dem Environment

  ${name:string}: Ein String wird in das Attribut/Textknoten eingefügt
  {string <ocaml-name>}

  ${name:att_value}: Das Attribut wird auf den att_value gesetzt.
    NUR so: attribut="${name:att_value}"
  {att_value <ocaml-name>}

  ${name:node}: Ein einzelner Knoten
  {node <ocaml-name>}

  ${name:nodelist}: Eine liste von Knoten
  {nodes <ocaml-name>}

  Beispiel:

  let m = <element< <a href="abc">The hyperlink to ${dest:string}</a> >>
  let m = <element< <a href="abc">The hyperlink to {string dest}</a> >>

  Ergibt: m : string -> 'ext node
          m : dest:string -> 'ext node

  Die Leerzeichen vor <a> und nach </a> werden ignoriert

  spec, dtd: feste ocaml-Bezeichner


  <xml< <element>...</element> >>
  <xml< <?pi ...?> >>
  <xml< <!-- ... --> >>
  <xml< data >>           (Leerzeichen am Anfang und Ende ignoriert)

  Der XML-Ausdruck wird im well-formed-Modus gelesen. Daher wird kein
  ignorable whitespace erkannt.

  <declaredtd< DTD >>  ??? (later)
    - Entity-Definitionen benutzen
    - Validierung des Ausdrucks ??? Geht evtl. nicht
    - Ignorable whitespace

  Namespaces?
