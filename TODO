- Fix: pxp-1.1.4 enthält Datei src/pxp-wlex/pxp_wlex.ml die nicht
  aktuell ist
  (auch im release-Skript fixen: pxp_wlex.ml muss aktueller sein als
  pxp_wlex.mlw)

- Klasse wfdocument

------------------------------

- Pxp_lexing: fast_from_function programmieren, das direkt den lexbuf
  benutzt.

- Pxp_dtd.Entity: get_resolver

- Pxp_entity: method copy (relocate)

- Pxp_marshal.relocate_document: copy the entities, too

- Resolvers: get_base_uri

------------------------------

- Separate well-formed documents from validated documents
  + Generalize DTDs so that schemas can be implemented

- PXP 1.2: Adapter to Nethtml: Parses HTML and converts it to a PXP object
  tree.

- PXP 1.2: embedded XML (see below)

- PXP 1.2: XPATH

- PXP 1.2: Adapter to Netclient

Problems with Pxp_reader: there should be some notion of "relative URI"
vs. "absolute URI". Currently, processing of relative URIs works only
if the active resolver always accepts relative URIs. I.e. it works but
is error-prone.
Idea: open_in has new argument ~scheme:
  - Some "http":    The URI is absolute
  - Some "":        The URI is empty, or Private, or Anonymous
  - None:           The URI is relative
'combine' would interpret the rejection of a relative URI as an error.

Pxp_reader: Perhaps a Redirection exception could be useful.
See netclient.

Pxp_document: The representation of the children list needs to be
improved. Perhaps a balanced tree would work well that allows accesses
by index.

----------------------------------------------------------------------

- E-XML:

  <dtd< dtd material >>

  <element< xml material >>  --> transformiert in eine FUNKTION, die mit
	create_xxx den Term zusammenbaut. Mittels $-Notation läßt sich angeben,
        welche (benannten) Argumente die Funktion hat.

  <data< text material >>

  spec, dtd: aus dem Environment

  ${name:string}: Ein String wird in das Attribut/Textknoten eingefügt

  ${name:att_value}: Das Attribut wird auf den att_value gesetzt.
    NUR so: attribut="${name:att_value}"

  ${name:node}: Ein einzelner Knoten

  ${name:nodelist}: Eine liste von Knoten

  Beispiel:

  let m = <element< <a href="abc">The hyperlink to ${dest:string}</a> >>

  Ergibt: m : string -> 'ext node

  Die Leerzeichen vor <a> und nach </a> werden ignoriert
