alan Schmitt:

Hi,

I unfortunately had to upgrade my OCaml to the latest cvs version, and
I'm having a hard time getting pxp to compile. The problem occurs both
with 1.1.5 and 1.1.93, and is the following:

ocamlfind ocamlc -g  -package "netstring" -c pxp_lexing.ml
File "pxp_lexing.ml", line 60, characters 2-255:
Some record field labels are undefined: lex_mem lex_start_p lex_curr_p

This is because the lexbuf data structure is now:
type lexbuf =
  { refill_buff : lexbuf -> unit;
    mutable lex_buffer : string;
    mutable lex_buffer_len : int;
    mutable lex_abs_pos : int;
    mutable lex_start_pos : int;
    mutable lex_curr_pos : int;
    mutable lex_last_pos : int;
    mutable lex_last_action : int;
    mutable lex_eof_reached : bool;
    mutable lex_mem : int array;
    mutable lex_start_p : position;
    mutable lex_curr_p : position;
  }

Are you aware of this change, and are you planning on releasing another
development version ?

DONE (UNTESTED)

Another (small, easily solved) bug is that "parser" is a keyword, and
needs to be changed in lines 2098 and 2104 of pxp-engine/pxp_yacc.m2y

DONE

-------

- examples/xhtml2html:
  einchecken, in release aufnehmen

  DONE

- Extended names für resolver:
  type extended_ext_id =
    { xid_private: private_id option;
      xid_public:  string option;
      xid_system:  url option;
      xid_system_base: url option;  (* when xid_system is relative *)
    }

  method open_in_extended xxid = ...
  
  open_in wird auf open_in_extended abgebildet.

  ExtID -> benutzt open_in
  XExtId -> benutzt open_in_extended direkt

  method active_id = ... gibt extended ID zurück, wobei nicht
  genutzte Namen auf None gesetzt werden können. Das entity
  holt sich die active_id nach dem Öffnen.

  Jeder Resolver kann sich unter den drei angebotenen (private, public,
  system) den passenden aussuchen. relative URLs werden nicht mehr
  vom resolver aufgelöst, sondern vom Entity.

  combine benutzt keine preferred resolvers mehr, sondern sucht stets
  von vorne.

  DONE

  neue Klasse fake_system. Wenn der untergeordnete resolver
  funktioniert, wird xid_system auf eine bestimmte URL gesetzt.
  ???

- Warners: Polymorphic variants benutzen.
  Cannot_represent auch als Fehler!  (A. Frisch)
  DONE

- Doku: Sektion "Known problems"
  * Non-representable characters. Kann zu well-formedness errors führen.

- Check:
  Pxp_lexers: Thread-safe? Reentrant?
  DONE

- Unicode:
  Include Characters > 0xFFFF
  DONE

- Lexers:
  einchecken,  DONE
  wlex-Support DONE

- Ausgabe von XML verbessern:
  * derived DTDs richtig ausgeben können

    schwierig, man muss ein extdecl vergleichbares Flag hinzunehmen,
    dass true ist, wenn per SYSTEM/PUBLIC in ein external entity
    verzweigt wird

    Optionale ?domain-Attribute. Gültige domains:
    - Ext_subset:       im SYSTEM/PUBLIC-Entity oder in einem
                        von dort angesteuerten Entity
    - Int_subset:       Direkt im internal subset definiert
    - Ext_ent_of_int_subset:  In einem externen Entity, das
                        in das internal subset inkludiert wird.
    
    Default ist Int_subset.

    Frage: (1) Zählt nur der Ort der Deklaration, oder auch, wo
               das deklarierende Entity angezogen wird?
           (2) Kann man extdecl-Flags auf domains reduzieren?

    NICHT IN 1.2. Das ist viel zu schwierig. Eher in die Richtung entwickeln,
    den internal subset orignalgetreu wiederzugeben (z.B. indem man den
    Token-Strom aufzeichnet). Das ist allerdings nur für geparste DTDs
    sinnvoll; was machen wir mit selbsterzeugten DTDs und modifizierten
    DTDs?

  * Optionen: Elemente ausgegeben ja/nein usw.
  ???

  * event-based parser: Entities NICHT auflösen
  NICHT IN 1.2

- Auch bei parse_wfdocument_entity die DTD transformieren können
  DONE
 
- resolver: externe entities nicht parsen (durch "" ersetzen)
  NICHT NOTWENDIG. Kann durch Pxp_reader auf einfache Weise bereitgestellt
  werden.

- from_string ~alt
  DONE

- Wirkung von `Extend_dtd_fully auch bei parse_wfdocument_entity ???
    Geht wohl nicht.

- ocamlnet-channels unterstützen, sowohl bei input-channels als
    auch output
  DONE

- Doku:
    - Wann ist dtd#root gesetzt?
    - Wann ist dtd#id gesetzt?
  DONE

- Event-based parsers:

  * Parse a single element, PI, comment, ... instead of misc* element misc*
    DONE

  * process_entity: erstes Token kann übergeben werden DONE
    Letztes Token? DONE

    Problem: m2parsergen erzwingt, dass immer ein Token zuviel gelesen
    wird. Mögliche Lösung: Eine Grammatikregel wird mit ! markiert;
    diese liest dann nicht ein weiteres Token. Nur erlaubt bei Regeln,
    die auf ein Token enden. Dies erfordert auch eine Änderung des
    Aufrufs.

    Problem: Um process_expr zu benutzen, muss man low-level entity
    Methoden aufrufen. Eine bessere API finden.

  * { and } inside attribute lists DONE
    
    TODO: Don't forget: pxp_lex_content_string.src: more efficient way of
    handling character sequences

  * Signature for entity_manager

  * Examples

  * Pull parser DONE

  * Review Pullparser + Entry_expr

  * Namespaces
    TODO: test

  * Pxp_ev_parser: stream parser
    (In Kommentar erläutert) DONE

  * Pxp_ev_parser: Filter, der ignorable whitespace löscht
    DONE

  * Filter, der char data normalisiert
    DONE

  * CHECK: Attributwerte

  * Pxp_document: erzeugen aus event stream; abbilden in event stream

  * Wie bricht man einen stream parser vorzeitig ab? Dateien schließen!

  * Namespaces und DTDs: Eine pxp:dtd processing instruction, um den
    Default-Namespace für Element-Deklarationen in DTDs zu setzen.
    <?pxp:dtd xmlns="..."?>

- Follow-Ups:

  * Clean-up of lexer definitions
    ???

  * Clean-Up of pxp_yacc.m2y: separate tree_parser and event_parser.
    They have a common superclass where event methods are virtual.

    Pxp_grammar: Contains grammar and state classes
    Pxp_parse_tree: Only entry points for tree parser
    Pxp_parse_events: Only entry points for event-based parser
    Pxp_yacc: compatibility interface

    DONE

  * extend_dtd: export? DONE

  * standalone DONE

  * Clean-Up of Pxp_entity. At least define class type entity (in .ml).

  * Pxp_light: XML-Baum als rekursiver Typ
    Pxp_light_trans: Light-Darstellung von/nach Heavy-Darstellung konvertieren
    Pxp_light_docemu: Light-Darstellung als Document-kompatible Klasse

    NICHT IN PXP 1.2

  * Undo pxp_lexing.mlp DONE

- Improvements:

  * Clone nodes and change DTD

  * parse_wfdocument_entity: argument ~share_dtd

  * pxp_reader uses netchannels instead of channels
    DONE

- pxpvalidate braucht hook um Baum teilweise zu löschen.


- Packen:

  * pxp.files aktualisieren
  * pxp_wlex_utf8_01.ml vorgenerieren


------------------------------

- Klasse wfdocument???

  Problemlage:
   - Bei Wf-dokumenten keine Deklarationen ausgeben (ausser entities)
     ==> Könnten auch write-Optionen leisten
   - keine allow_arbitrary-PI ausgeben
   - Überprüfung des root-Elements separieren

------------------------------

- Pxp_lexing: fast_from_function programmieren, das direkt den lexbuf
  benutzt.

- Pxp_dtd.Entity: get_resolver

- Pxp_entity: method copy (relocate)

- Pxp_marshal.relocate_document: copy the entities, too

- Resolvers: get_base_uri
  NICHT NOTWENDIG, active_id des parent-resolvers tut es.

------------------------------

- Separate well-formed documents from validated documents
  + Generalize DTDs so that schemas can be implemented

- PXP 1.2: Adapter to Nethtml: Parses HTML and converts it to a PXP object
  tree.

  ==> module Pxp_html

- PXP 1.2: embedded XML (see below)

- PXP 1.2: XPATH

  ==> module Pxp_xpath definiert XPATH-Kernfunktionen

- PXP 1.2: Adapter to Netclient

Problems with Pxp_reader: there should be some notion of "relative URI"
vs. "absolute URI". Currently, processing of relative URIs works only
if the active resolver always accepts relative URIs. I.e. it works but
is error-prone.
Idea: open_in has new argument ~scheme:
  - Some "http":    The URI is absolute
  - Some "":        The URI is empty, or Private, or Anonymous
  - None:           The URI is relative
'combine' would interpret the rejection of a relative URI as an error.

Pxp_reader: Perhaps a Redirection exception could be useful.
See netclient.

Pxp_document: The representation of the children list needs to be
improved. Perhaps a balanced tree would work well that allows accesses
by index.

----------------------------------------------------------------------

- E-XML:

  <dtd< dtd material >>

  <element< xml material >>  --> transformiert in eine FUNKTION, die mit
	create_xxx den Term zusammenbaut. Mittels $-Notation läßt sich angeben,
        welche (benannten) Argumente die Funktion hat.

  <data< text material >>

  spec, dtd: aus dem Environment

  ${name:string}: Ein String wird in das Attribut/Textknoten eingefügt
  {string <ocaml-name>}

  ${name:att_value}: Das Attribut wird auf den att_value gesetzt.
    NUR so: attribut="${name:att_value}"
  {att_value <ocaml-name>}

  ${name:node}: Ein einzelner Knoten
  {node <ocaml-name>}

  ${name:nodelist}: Eine liste von Knoten
  {nodes <ocaml-name>}

  Beispiel:

  let m = <element< <a href="abc">The hyperlink to ${dest:string}</a> >>
  let m = <element< <a href="abc">The hyperlink to {string dest}</a> >>

  Ergibt: m : string -> 'ext node
          m : dest:string -> 'ext node

  Die Leerzeichen vor <a> und nach </a> werden ignoriert

  spec, dtd: feste ocaml-Bezeichner


  <xml< <element>...</element> >>
  <xml< <?pi ...?> >>
  <xml< <!-- ... --> >>
  <xml< data >>           (Leerzeichen am Anfang und Ende ignoriert)

  Der XML-Ausdruck wird im well-formed-Modus gelesen. Daher wird kein
  ignorable whitespace erkannt.

  <declaredtd< DTD >>  ??? (later)
    - Entity-Definitionen benutzen
    - Validierung des Ausdrucks ??? Geht evtl. nicht
    - Ignorable whitespace

  Namespaces?
