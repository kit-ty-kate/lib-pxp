- Check:
  Pxp_lexers: Thread-safe? Reentrant?

- Unicode:
  Include Characters > 0xFFFF

- Lexers:
  einchecken,  DONE
  wlex-Support DONE

- Event-based parsers:

  * Parse a single element, PI, comment, ... instead of misc* element misc*
    DONE

  * process_entity: erstes Token kann übergeben werden DONE
    Letztes Token? DONE

    Problem: m2parsergen erzwingt, dass immer ein Token zuviel gelesen
    wird. Mögliche Lösung: Eine Grammatikregel wird mit ! markiert;
    diese liest dann nicht ein weiteres Token. Nur erlaubt bei Regeln,
    die auf ein Token enden. Dies erfordert auch eine Änderung des
    Aufrufs.

    Problem: Um process_expr zu benutzen, muss man low-level entity
    Methoden aufrufen. Eine bessere API finden.

  * { and } inside attribute lists DONE
    
    TODO: Don't forget: pxp_lex_content_string.src: more efficient way of
    handling character sequences

  * Signature for entity_manager

  * Examples

  * Pull parser DONE

  * Review Pullparser + Entry_expr

- Follow-Ups:

  * Clean-up of lexer definitions

  * Clean-Up of pxp_yacc.m2y: separate tree_parser and event_parser.
    They have a common superclass where event methods are virtual.

    Pxp_grammar: Contains grammar and state classes
    Pxp_parse_tree: Only entry points for tree parser
    Pxp_parse_events: Only entry points for event-based parser
    Pxp_yacc: compatibility interface

  * extend_dtd: export? DONE

  * standalone DONE

  * Clean-Up of Pxp_entity. At least define class type entity (in .ml).

  * Pxp_light: XML-Baum als rekursiver Typ
    Pxp_light_trans: Light-Darstellung von/nach Heavy-Darstellung konvertieren
    Pxp_light_docemu: Light-Darstellung als Document-kompatible Klasse

  * Undo pxp_lexing.mlp DONE

- Improvements:

  * Clone nodes and change DTD

  * parse_wfdocument_entity: argument ~share_dtd

- Packen:

  * pxp.files aktualisieren
  * pxp_wlex_utf8_01.ml vorgenerieren

------------------------------

- Klasse wfdocument

------------------------------

- Pxp_lexing: fast_from_function programmieren, das direkt den lexbuf
  benutzt.

- Pxp_dtd.Entity: get_resolver

- Pxp_entity: method copy (relocate)

- Pxp_marshal.relocate_document: copy the entities, too

- Resolvers: get_base_uri

------------------------------

- Separate well-formed documents from validated documents
  + Generalize DTDs so that schemas can be implemented

- PXP 1.2: Adapter to Nethtml: Parses HTML and converts it to a PXP object
  tree.

  ==> module Pxp_html

- PXP 1.2: embedded XML (see below)

- PXP 1.2: XPATH

  ==> module Pxp_xpath definiert XPATH-Kernfunktionen

- PXP 1.2: Adapter to Netclient

Problems with Pxp_reader: there should be some notion of "relative URI"
vs. "absolute URI". Currently, processing of relative URIs works only
if the active resolver always accepts relative URIs. I.e. it works but
is error-prone.
Idea: open_in has new argument ~scheme:
  - Some "http":    The URI is absolute
  - Some "":        The URI is empty, or Private, or Anonymous
  - None:           The URI is relative
'combine' would interpret the rejection of a relative URI as an error.

Pxp_reader: Perhaps a Redirection exception could be useful.
See netclient.

Pxp_document: The representation of the children list needs to be
improved. Perhaps a balanced tree would work well that allows accesses
by index.

----------------------------------------------------------------------

- E-XML:

  <dtd< dtd material >>

  <element< xml material >>  --> transformiert in eine FUNKTION, die mit
	create_xxx den Term zusammenbaut. Mittels $-Notation läßt sich angeben,
        welche (benannten) Argumente die Funktion hat.

  <data< text material >>

  spec, dtd: aus dem Environment

  ${name:string}: Ein String wird in das Attribut/Textknoten eingefügt
  {string <ocaml-name>}

  ${name:att_value}: Das Attribut wird auf den att_value gesetzt.
    NUR so: attribut="${name:att_value}"
  {att_value <ocaml-name>}

  ${name:node}: Ein einzelner Knoten
  {node <ocaml-name>}

  ${name:nodelist}: Eine liste von Knoten
  {nodes <ocaml-name>}

  Beispiel:

  let m = <element< <a href="abc">The hyperlink to ${dest:string}</a> >>
  let m = <element< <a href="abc">The hyperlink to {string dest}</a> >>

  Ergibt: m : string -> 'ext node
          m : dest:string -> 'ext node

  Die Leerzeichen vor <a> und nach </a> werden ignoriert

  spec, dtd: feste ocaml-Bezeichner


  <xml< <element>...</element> >>
  <xml< <?pi ...?> >>
  <xml< <!-- ... --> >>
  <xml< data >>           (Leerzeichen am Anfang und Ende ignoriert)

  Der XML-Ausdruck wird im well-formed-Modus gelesen. Daher wird kein
  ignorable whitespace erkannt.

  <declaredtd< DTD >>  ??? (later)
    - Entity-Definitionen benutzen
    - Validierung des Ausdrucks ??? Geht evtl. nicht
    - Ignorable whitespace

  Namespaces?
