- Event-based parsers:

  rec_curly_parse "<!DOCTYPE A [ <!ENTITY b '}'> ]> <A>{<B>xxx</B>&b;</A>";;

  Idee: create_proxy muss selbst aufgerufen werden statt ~inside_entity.

  * When calling the parser, pass the entity_manager, not the source
    ( ==> parser can recursively call itself )

  * Parse a single element, PI, comment, ... instead of misc* element misc*

  * { and } inside attribute lists

  * Check: standalone flag

  * Signature for entity_manager

  * Examples

- Follow-Ups:

  * Clean-Up of pxp_yacc.m2y: separate tree_parser and event_parser.
    They have a common superclass where event methods are virtual.

  * extend_dtd: export?

    process_entity kann im wf-Modus oder im validating-Modus aufgerufen
    werden. dies hat aber nur Einfluss auf die konstruktion der DTD.

  * standalone

------------------------------

- Klasse wfdocument

------------------------------

- Pxp_lexing: fast_from_function programmieren, das direkt den lexbuf
  benutzt.

- Pxp_dtd.Entity: get_resolver

- Pxp_entity: method copy (relocate)

- Pxp_marshal.relocate_document: copy the entities, too

- Resolvers: get_base_uri

------------------------------

- Separate well-formed documents from validated documents
  + Generalize DTDs so that schemas can be implemented

- PXP 1.2: Adapter to Nethtml: Parses HTML and converts it to a PXP object
  tree.

- PXP 1.2: embedded XML (see below)

- PXP 1.2: XPATH

- PXP 1.2: Adapter to Netclient

Problems with Pxp_reader: there should be some notion of "relative URI"
vs. "absolute URI". Currently, processing of relative URIs works only
if the active resolver always accepts relative URIs. I.e. it works but
is error-prone.
Idea: open_in has new argument ~scheme:
  - Some "http":    The URI is absolute
  - Some "":        The URI is empty, or Private, or Anonymous
  - None:           The URI is relative
'combine' would interpret the rejection of a relative URI as an error.

Pxp_reader: Perhaps a Redirection exception could be useful.
See netclient.

Pxp_document: The representation of the children list needs to be
improved. Perhaps a balanced tree would work well that allows accesses
by index.

----------------------------------------------------------------------

- E-XML:

  <dtd< dtd material >>

  <element< xml material >>  --> transformiert in eine FUNKTION, die mit
	create_xxx den Term zusammenbaut. Mittels $-Notation läßt sich angeben,
        welche (benannten) Argumente die Funktion hat.

  <data< text material >>

  spec, dtd: aus dem Environment

  ${name:string}: Ein String wird in das Attribut/Textknoten eingefügt

  ${name:att_value}: Das Attribut wird auf den att_value gesetzt.
    NUR so: attribut="${name:att_value}"

  ${name:node}: Ein einzelner Knoten

  ${name:nodelist}: Eine liste von Knoten

  Beispiel:

  let m = <element< <a href="abc">The hyperlink to ${dest:string}</a> >>

  Ergibt: m : string -> 'ext node

  Die Leerzeichen vor <a> und nach </a> werden ignoriert
