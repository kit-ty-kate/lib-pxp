(* $Id: pxp_lex_content_string.src,v 1.7 2002/08/05 22:35:06 gerd Exp $
 * ----------------------------------------------------------------------
 *
 *)


{
  open Pxp_types
  open Pxp_lexer_types

#insert open_pxp_lex_aux_*.src
}

#insert pxp_lex_defs_*.def

(* This lexer is used to expand and normalize attribute values: *)

(* TODO: Use ERef_att instead of ERef *)

rule scan_content_string = parse
    '&' name ';'
      { let s = Lexing.lexeme lexbuf in
	ERef (String.sub s 1 (String.length s - 2)) }
  | "&#" ascii_digit+ ";"
      { let s = Lexing.lexeme lexbuf in
	CRef (int_of_string (String.sub s 2 (String.length s - 3))) }
  | "&#x" ascii_hexdigit+ ";"
      { let s = Lexing.lexeme lexbuf in
	CRef (int_of_string ("0x" ^ String.sub s 3 (String.length s - 4))) }
  | '&'
      { raise(WF_error("The character '&' must be written as '&amp;'")) }
  | printable_character_except_amp_lt+
      { CharData "" (* (Lexing.lexeme lexbuf) *) } 
  | '\009'
      { CRef 32 }
  | '\013' '\010'
      { CRef(-1)   (* A special case *)
      }
  | '\013'
      { CRef 32 }
  | '\010'
      { CRef 32 }
  | '<'
      { 
	(* Depending on the situation, '<' may be legal or not: *)
	CharData "<" 
      }
  | eof
      { Eof }
  | _
      { raise Netconversion.Malformed_code }


(* The following lexer is an alternative. It is used if event-based
 * attribute parsing is enabled.
 *
 * Note: The argument of the functions is whether the attribute value
 * is delimited by double quotes (true) or single quotes (false).
 *)

and scan_tag_eb_att = parse
    '&' name ';'
      { fun d ->
	  let s = Lexing.lexeme lexbuf in
	  (ERef_att (String.sub s 1 (String.length s - 2)), Tag_eb_att d) 
      }
  | "&#" ascii_digit+ ";"
      { fun d ->
	  let s = Lexing.lexeme lexbuf in
	  (CRef (int_of_string (String.sub s 2 (String.length s - 3))),
	   Tag_eb_att d)
      }
  | "&#x" ascii_hexdigit+ ";"
      { fun d ->
	  let s = Lexing.lexeme lexbuf in
	  (CRef (int_of_string ("0x" ^ String.sub s 3 (String.length s - 4))),
	   Tag_eb_att d)
      }
  | '&'
      { fun _ ->
          raise(WF_error("The character '&' must be written as '&amp;'")) }
  | '\009'
      { fun d ->
          CharData " ", Tag_eb_att d }
  | '\013' '\010'
      { fun d ->
	  LineEnd_att "  ", Tag_eb_att d }
  | '\013'
      { fun d ->
          LineEnd_att " ", Tag_eb_att d }
  | '\010'
      { fun d ->
          LineEnd_att " ", Tag_eb_att d }
  | '<'
      { fun d ->
	  (* Depending on the situation, '<' may be legal or not: *)
	  CharData "<", Tag_eb_att d
      }
  | '"' 
      { function
          true  -> DQuote, Tag_eb
        | false -> CharData "\"", Tag_eb_att false
      }
  | '\'' 
      { function
          true  -> CharData "'", Tag_eb_att true
        | false -> SQuote, Tag_eb
      }
  | "{{"
      { fun d -> LLcurly, Tag_eb_att d }
  | "{"
      { fun d -> Lcurly, Tag_eb_att d }
  | "}}"
      { fun d -> RRcurly, Tag_eb_att d }
  | "}"
      { fun d -> Rcurly, Tag_eb_att d }
  | printable_character_except_amp_lt        (* TODO !!! *)
      { fun d -> CharData (Lexing.lexeme lexbuf), Tag_eb_att d } 
  | eof
      { fun d -> Eof, Tag_eb_att d }
  | _
      { fun _ -> raise Netconversion.Malformed_code }



(* ======================================================================
 * History:
 * 
 * $Log: pxp_lex_content_string.src,v $
 * Revision 1.7  2002/08/05 22:35:06  gerd
 * 	Fixed newline characters in attribute values for event-based
 * attribute parsing.
 *
 * Revision 1.6  2002/08/03 17:56:27  gerd
 * 	Support for event-based parsing of attribute values.
 *
 * Revision 1.5  2001/06/14 14:25:56  gerd
 * 	Removed insertion of pxp_lex_aux.src
 *
 * Revision 1.4  2000/10/01 19:51:33  gerd
 * 	Optimizations.
 *
 * Revision 1.3  2000/08/14 22:18:34  gerd
 * 	Bad_character_stream -> Netconversion.Malformed_code
 *
 * Revision 1.2  2000/05/29 23:53:12  gerd
 * 	Updated because Markup_* modules have been renamed to Pxp_*.
 *
 * Revision 1.1  2000/05/20 20:33:25  gerd
 * 	Initial revision.
 *
 * 
 *)
