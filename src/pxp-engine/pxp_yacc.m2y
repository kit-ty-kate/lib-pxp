(* $Id: pxp_yacc.m2y,v 1.1 2000/05/29 23:48:38 gerd Exp $
 * ----------------------------------------------------------------------
 * PXP: The polymorphic XML parser for Objective Caml.
 * Copyright by Gerd Stolpmann. See LICENSE for details.
 *)

open Parsing

open Pxp_types

open Pxp_lexer_types
    (* This 'open' overrides the definition of the type 'token' that has been
     * generated by ocamlyacc.
     * THIS IS VERY CRITICAL.
     *)

open Pxp_dtd
open Pxp_entity
open Pxp_document
open Pxp_aux

(* Some types from the interface definition: *)

type config =
    { warner : collect_warnings;
      errors_with_line_numbers : bool;
      processing_instructions_inline : bool;
      virtual_root : bool;
      encoding : rep_encoding;
      recognize_standalone_declaration : bool;
      debugging_mode : bool;
    }

type source =
    Entity of ((dtd -> Pxp_entity.entity) * Pxp_reader.resolver)
  | Channel of in_channel
  | File of string
  | Latin1 of string
  | ExtID of (ext_id * Pxp_reader.resolver)


type 'ext domspec =
    { map : (node_type, 'ext node) Hashtbl.t;
      default_element : 'ext node;
    }
    (* specifies which node to use as exemplar for which node type *)


type start_symbol =
    Ext_document
  | Ext_declarations
  | Ext_element


type context =
    { mutable current : unit -> token;
      mutable get_next : unit -> token;
      mutable current_token : token;
      mutable manager : entity_manager;
    }


let make_context entity_manager =
  let c =
    { current = (fun _ -> assert false);
      get_next = (fun _ -> assert false);
      current_token = Eof;
      manager = entity_manager;
    }
  in
  let get_next_ref = entity_manager # yy_get_next_ref in
  c.current  <- (fun () -> c.current_token);
  c.get_next <- (fun () -> let tok = !get_next_ref() in
		           c.current_token <- tok;
		           tok);
  ignore(c.get_next());
  c
;;


  (* This parser works with side effects. This is not optimal but currently
   * the simplest approach. In order to have better control of the side
   * effects, the parser is artifically turned into an object. This is done
   * by a "sed" script in the Makefile that changes some of the generated "let"
   * definitions into "val" definitions and the other "let" definitions into
   * "method" definitions.
   * We begin here the class:
   *)

  (**********************************************************************)

class ['ext] parser_object
  init_doc init_dtd init_extend_dtd init_config init_resolver init_dom 
  init_process_xmldecl
  =
  object (self)

      (* Note that the 'ext parameter has been the motivation to make the
       * parser a class.
       *)

    val dtd = init_dtd
	(* The DTD being parsed; or the DTD currently assumed *)

    val extend_dtd = init_extend_dtd
	(* Whether the DTD should be extended by ELEMENT, ATTLIST, and
	 * NOTATION declarations or not.
	 *)

    val process_xmldecl = init_process_xmldecl
        (* Whether the XML declaration is parsed and the found XML version
	 * and standalone declaration are passed to 'doc'.
	 *)

    val lexerset = Pxp_lexers.get_lexer_set (init_config.encoding)

    val doc = init_doc
        (* The current document *)

    method doc = (doc : 'ext document)

    val resolver = init_resolver
        (* The resolver for external IDs *)

    val config = init_config
        (* The current configuration *)

    val elstack = (Stack.create() : ('ext node * entity_id) Stack.t)
       (* The element stack containing all open elements, i.e. elements that
	* have begun by a start tag but that have not been finished (end tag).
	* If the parser sees a start tag, it creates the element and pushes it
	* on top of this stack. If the parser recognizes an end tag, it pulls
	* one element from the stack and checks if it has the same name as
	* given with the end tag.
	*
	* At initialization time, a special element is pushed on the stack,
	* the so-called virtual root (vr). It is always the bottommost
	* element of the stack, and serves as a guard.
	* [See "initializer" below.]
	*)
		    
    method current =
	(* Get the top element of the element stack *)
	(* In O'Caml 3: Stack.top *)
	try
	  let x = Stack.pop elstack in
	  Stack.push x elstack;
	  let el, entid = x in
	  el
	with
	    Stack.Empty -> assert false
		(* Not possible, because the VR is always the element at the
		 * bottom of the stack.
		 *)

    val mutable n_tags_open = 0
	(* Number of begin tags that have been parsed and whose corresponding
	 * end tags have not yet been parsed
	 *)

    val mutable p_internal_subset = false
        (* true while parsing the internal subset *)

    val mutable root = None
        (* Contains the root element (topmost element) while it is being parsed
	 * and after it has been parsed.
	 * This variable is None before the root element is seen.
	 *)

    method root = root

    val dom = init_dom
        (* A hashtable that contains exemplar objects for the various element
	 * types. If an element is parsed, the exemplar is looked up and
	 * "cloned" (by the "create" method)
	 *)

    val data_exemplar =
      try
	Hashtbl.find init_dom.map T_data
      with
	  Not_found ->
	    failwith "Pxp_yacc.parser_object: The initial DOM map does not specify T_data nodes"

    method only_whitespace data =
	(* Checks that the string "data" contains only whitespace. On failure,
	 * Validation_error is raised.
	 *)
      let lexbuf = Lexing.from_string data in
      let t1 = lexerset.scan_name_string lexbuf in
      if t1 <> Ignore then
	raise(WF_error("Data not allowed here"));
      let t2 = lexerset.scan_name_string lexbuf in
      if t2 <> Eof then
	raise(WF_error("Data not allowed here"));
      ()

    initializer
      (* CHECKS: *)
      if config.encoding <> dtd # encoding then
	failwith("Encoding mismatch");

	(* --- Initialize 'elstack': Push the VR on the stack. *)
	(* If we are NOT in virtual_root mode, any element serves as VR,
	 * because no method is ever called on this element. We simply
	 * take the default exemplar.
	 * IF we are in virtual_root mode, the VR is created (almost)
	 * normally.
	 *)
      let vr =
	if config.virtual_root then begin
	  (* Get the 'exemplar', as usual: *)
          let exemplar =
	    try Hashtbl.find dom.map (T_element "-pi")
	    with Not_found -> dom.default_element in
	  (* A trick: while the 'vr' is being created, the DTD is
	   * changed such that this is allowed.
	   *)
	  let aa = dtd # arbitrary_allowed in        (* save old state    *)
	  dtd # allow_arbitrary;
	  let vroot =
	    exemplar # create_element dtd (T_element "-vr") [] in
	  if not aa then dtd # disallow_arbitrary;   (* restore old state *)
	  vroot
	end
	else
	  dom.default_element
      in
      (* Move it to the stack: *)
      Stack.push (vr, (self :> entity_id)) elstack;

      method parse context start_symbol =

	let parse_ignored_section yy_current yy_get_next =
	  (* A special parser which should be used after <![IGNORE[.
	   * It parses until the corresponding ]]> is found.
	   *)
          (* WS *)

          while yy_current() = Ignore do
	    ignore(yy_get_next());
	  done;

	  ( match yy_current() with
	      Conditional_body _ -> ()
	    | _                  -> raise Parsing.Parse_error;
	  );

	  let en = context.manager # current_entity in
	  let llev = ref 1 in
	  while !llev >= 1 do
	    let igntok = en # next_ignored_token in
	    (* next_ignored_token: uses a special lexer that only
	     * recognizes Conditional_begin and Conditional_end;
	     * other character combinations are ignored.
	     *)
	    (* NOTE: next_ignored_token works much like yy_get_next,
	     * but it does not set the current token!
	     *)
	    match igntok with
		Conditional_begin _ ->
		  llev := !llev + 1
	      | Conditional_end _ ->
		  llev := !llev - 1;
		  (* Because the loop may be exited now: *)
		  context.current_token <- igntok;
	      | (End_entity | Eof) ->
		  raise Parsing.Parse_error
	      | _ ->
		  ()
	  done;
	  
	in


	let check_and_parse_xmldecl xmldecl =
	  if process_xmldecl then begin
	    let v, _, s = decode_doc_xml_pi (decode_xml_pi xmldecl) in
	    check_version_num v;
	    doc # init_xml_version v;
	    let v = match s with
		None -> false
	      | Some "yes" -> true
	      | Some "no" -> false
	      | _ -> raise (WF_error("Illegal 'standalone' declaration"))
	    in
	    if config.recognize_standalone_declaration then 
	      dtd # set_standalone_declaration v
	  end
	in
	
%%

/* See Pxp_types.ml for comments */

%token Begin_entity
%token End_entity
%token Comment
%token Ignore
%token Eq
%token Rangle
%token Rangle_empty
%token <> Conditional_begin
%token <> Conditional_body
%token <> Conditional_end
%token Percent
%token Plus
%token Star
%token Bar
%token Comma
%token Qmark
%token Pcdata
%token Required
%token Implied
%token Fixed
%token Eof

%token <> Doctype
%token <> Doctype_rangle
%token <> Dtd_begin
%token <> Dtd_end
%token <> Decl_element
%token <> Decl_attlist
%token <> Decl_entity
%token <> Decl_notation
%token <> Decl_rangle
%token <> Lparen
%token <> Rparen
%token <> RparenPlus
%token <> RparenStar
%token <> RparenQmark

%token <> Tag_beg
%token <> Tag_end

%token <> PI
%token <> PI_xml
%token <> Cdata
%token <> CRef
%token <> ERef
%token <> PERef
%token <> CharData
%token <> LineEnd
%token <> Name
%token <> Nametoken
%token <> Attval
%token <> Attval_nl_normalized
%token <> Unparsed_string

/* START SYMBOLS:
 *
 * "ext_document":       parses a complete XML document (i.e. containing a
 *                       <!DOCTYPE..> and an element)
 * "ext_declarations":   parses an "external DTD subset", i.e. a sequence
 *                       of declarations
 * "ext_element":        parses a single element (no <!DOCTYPE...> allowed);
 *                       the element needs not to be the root element of the
 *                       DTD
 *
 * The functions corresponding to these symbols return always () because
 * they only have side-effects.
 */

/* SOME GENERAL COMMENTS:
 *
 * The parser does not get its tokens from the lexers directly. Instead of
 * this, there is an entity object between the parser and the lexers. This
 * object already handles:
 *
 * - References to general and parameter entities. The token stream is
 *   modified such that tokens automatically come from the referenced entities.
 *   External parameter entities and all general entities are embraced by
 *   the two special tokens Begin_entity and End_entity. The parser must
 *   check that these braces are correctly nested.
 */

%%


ext_document():
  /* WS */
  Begin_entity 
  doc_xmldecl_then_misc_then_prolog_then_rest() End_entity
    {{
      if n_tags_open <> 0 then
	raise(WF_error("Missing end tag"))
    }}


/* In the following rule, we must find out whether there is an XML declaration
 * or not, and directly after that either "process_xmldecl" or 
 * "process_missing_xmldecl" of the current entity must be called.
 * AND IT MUST BE DIRECTLY! Because of this, the invocation is carried out
 * in the "$" clause immediately following the first token.
 *
 * TODO: This is not enough. The first token may be a tag, and the tag
 * may already contain non-ASCII characters. (But in this case, the resolvers
 * assume UTF8, and they are right...)
 */

doc_xmldecl_then_misc_then_prolog_then_rest():
  /* WS */
  pl:PI_xml 
  $ {{ context.manager # current_entity # process_xmldecl pl; 
       check_and_parse_xmldecl pl;
    }}
  misc()* doc_prolog_then_rest()
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  misc() misc()* doc_prolog_then_rest()
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  doctypedecl() misc()* contents_start()
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  contents_start()
    {{ () }}


doc_prolog_then_rest():
  /* WS */
  doctypedecl() misc()* contents_start()
    {{ () }}
| contents_start() 
    {{ () }}
 

ext_element():
  /* WS */
  Begin_entity el_xmldecl_then_misc_then_rest() End_entity
    {{
      if n_tags_open <> 0 then
	raise(WF_error("Missing end tag"))
    }}


/* See comment for doc_mldecl_then_misc_then_prolog_then_rest. */

el_xmldecl_then_misc_then_rest():
  /* WS */
  pl:PI_xml
  $ {{ context.manager # current_entity # process_xmldecl pl; }}
  misc()* contents_start() 
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  misc() misc()* contents_start() 
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  contents_start()
    {{ () }}


ext_declarations():
  /* Parses a sequence of declarations given by an entity. As side-effect,
   * the parsed declarations are put into the dtd object.
   */
  /* WS */
  Begin_entity decl_xmldecl_then_rest() 
   {{ () }}
| Eof
   {{ () }}


decl_xmldecl_then_rest():
  /* Note: This rule is also called from declaration()! */
  /* WS */
  pl:PI_xml
  $ {{ context.manager # current_entity # process_xmldecl pl; 
    }}
  declaration()* End_entity
   {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  declaration() declaration()* End_entity
   {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  End_entity
   {{ () }}


misc():
  /* WS */
  pi()
    {{ () }}
| data: CharData
    /* In this context, the lexers sometimes do not recognize white space; 
     * instead CharData tokens containing white space are delivered.
     */
    {{ self # only_whitespace data }}
| Ignore
    {{ () }}
| Comment
    {{ () }}


/********************* DOCUMENT TYPE DECLARATION *************************/

doctypedecl():
  /* parses from <!DOCTYPE to >. As side-effect, first the declarations of
   * the internal DTD (if any) are put into !!on_dtd, the the declarations
   * of the external DTD (if any) are put into this DTD object.
   * Note that "internal_dtd_opt" is always reduced before this rule, and
   * because of this the declarations of the internal DTD are parsed first.
   */
  /* WS */
  doctype_entid:  Doctype 
                  Ignore Ignore*
                  doctypedecl_material (doctype_entid)
    {{ () }}

doctypedecl_material(doctype_entid):
  /* WS */
  root_name:             Name
  ws:                    Ignore? Ignore*
  external_subset:       external_id()? 
                         Ignore*
  internal_subset:       internal_dtd()? 
                         Ignore*
  doctype_rangle_entid:  Doctype_rangle
    {{ 
      if doctype_entid != doctype_rangle_entid then
	raise (Validation_error("Entities not properly nested with DOCTYPE declaration"));
      dtd # set_root root_name;
      begin match external_subset, internal_subset with
	  None, None      -> ()         (* no DTD means no ID *)
	| None, Some _    -> dtd # set_id Internal
	| Some id, None   -> dtd # set_id (External id)
	| Some id, Some _ -> dtd # set_id (Derived id)
      end;
      (* Get now the external doctype declaration. Note that the internal
       * subset has precedence and must be read first.
       *)
      begin match external_subset with
	  None -> ()
	| Some id ->
	    if not ws then
	      raise(WF_error("Missing whitespace after `<!DOCTYPE " ^ 
			     root_name ^ "'"));
	    let r' = resolver # clone in
	    let pobj =
	      new parser_object
		(new document config.warner)
		dtd
		extend_dtd
		config
		r'
		dom
		process_xmldecl
	    in
	    let en = new external_entity r' dtd "[dtd]"
		         config.warner id false config.errors_with_line_numbers
		         config.encoding
	    in
	    en # set_debugging_mode (config.debugging_mode);
	    let mgr = new entity_manager en in
	    try
	      en # open_entity true Declaration;
	      let context = make_context mgr in
	      pobj # parse context Ext_declarations;
	      ignore(en # close_entity);
	    with
		error ->
		  ignore(en # close_entity);
		  let pos = mgr # position_string in
		  raise (At(pos, error))
      end;
      dtd # validate
    }}

/* Note that there are no keywords for SYSTEM or PUBLIC, because these would
 * be difficult to recognize in the lexical contexts. We are lucky because
 * SYSTEM is followed by exectly one string while PUBLIC is followed by two
 * strings, so we can distinguish between them.
 */


external_id():
  /* WS */
  tok:Name 
  $ {{ 
       let followup = 
	 match tok with
	     "SYSTEM" -> parse_system_id
	   | "PUBLIC" -> parse_public_id
	   | _        -> raise(WF_error("SYSTEM or PUBLIC expected"))
       in
     }}
  Ignore Ignore*
  r:[followup]()
    {{ r }}


system_id():
  str:Unparsed_string 
    {{ System str }}


public_id():
  str1: Unparsed_string 
        Ignore Ignore*
  str2: Unparsed_string
    {{ check_public_id str1;
       Public(str1,str2)
    }}


internal_dtd():
  /* WS */
  dtd_begin_entid:    internal_dtd_begin() 
                      declaration()* 
  dtd_end_entid:      internal_dtd_end()
    {{ 
      if dtd_begin_entid != dtd_end_entid then
	raise(Validation_error("Entities not properly nested with internal DTD subset"))
    }}


internal_dtd_begin():
  /* WS */
  Dtd_begin
    {{ assert (not p_internal_subset);
      p_internal_subset <- true }}


internal_dtd_end():
  /* WS */
  Dtd_end
    {{ assert p_internal_subset;
      p_internal_subset <- false }}


declaration():
  /* Parses a single declaration (or processing instruction). As side-effect
   * the parsed declaration is entered into the dtd object.
   */
  /* WS */
  elementdecl()
    {{ () }}
| attlistdecl()
    {{ () }}
| entid:Decl_entity Ignore Ignore* entitydecl(entid)
    {{ () }}
| notationdecl()
    {{ () }}
| pi: PI
    {{ let target, value = pi in
       let pi = new proc_instruction target value in
       dtd # add_pinstr pi
    }}
| Ignore
    {{ () }}
| Comment
    {{ () }}
| Begin_entity
  $ {{ (* Set 'p_internal_subset' to 'false' until the matching 'end_entity'
	* rule is parsed. This allows unrestricted usage of parameter entities
	* within declarations of internal entities.
	*)
       let old_p_internal_subset = p_internal_subset in
       p_internal_subset <- false;
    }}
  decl_xmldecl_then_rest()
    {{ (* Restore the old value of 'p_internal_subset'. *)
       p_internal_subset <- old_p_internal_subset;
       ()
    }}
| begin_entid:Conditional_begin
  $ {{ (* Check whether conditional sections are allowed at this position. *)
       if p_internal_subset then 
	 raise(WF_error("Restriction of the internal subset: Conditional sections not allowed"));
     }}
  Ignore*
  conditional_section()  end_entid:Conditional_end
    {{ (* Check whether Conditional_begin and Conditional_end are in the same
	* entity. (This restriction is explained in SPECS.xml.)
	*)
       if begin_entid != end_entid then
	 raise(Validation_error("The first and the last token of conditional sections must be in the same entity (addtional restriction of this parser)"));
 }}


conditional_section():
  /* WS */
  include_or_ignore:Name
  $ {{ let parsing_function =
	 match include_or_ignore with
	     "INCLUDE"  -> parse_included_section
                           (* invoke rule "included_section" below *)
	   | "IGNORE"   -> parse_ignored_section
                           (* invoke function "parse_ignored_section" *)
	   | _          -> raise(WF_error("INCLUDE or IGNORE expected"))
       in
    }}
  [ parsing_function ] ()  
    {{ () }}


included_section():
  /* WS */
  Conditional_body declaration()*  
    {{ () }}
| Ignore Ignore* Conditional_body declaration()*  
    {{ () }}


/*************************** ELEMENT DECLARATIONS ********************/

elementdecl():
  /* parses <!ELEMENT ... >. Puts the parsed element as side-effect into
   * dtd.
   */
  /* WS */
  decl_element_entid:      Decl_element 
  $ {{ let extdecl = context.manager # current_entity_counts_as_external in
     }}
                           Ignore Ignore*
  name:                    Name 
                           Ignore Ignore*
  content_model:           contentspec() 
                           Ignore*
  decl_rangle_entid:       Decl_rangle
    {{
      if decl_element_entid != decl_rangle_entid then
	raise (Validation_error "Entities not properly nested with ELEMENT declaration");
      if extend_dtd then begin
	let el = new dtd_element dtd name in
	(* It is allowed that an <!ATTLIST...>  precedes the corresponding
	 * <!ELEMENT...>. Because of this it is possible that there is already
	 * an element called 'name' in the DTD, and we must set the content
	 * model of this element.
	 *)
	try
	  dtd # add_element el;
	  el # set_cm_and_extdecl content_model extdecl;
	with
	    Not_found ->  (* means: there is already an element 'name' *)
	      let el' = dtd # element name in
	      el' # set_cm_and_extdecl content_model extdecl;
              (* raises Validation_error if el' already has a content model *)
      end
    }}

/* M2Y: TODO: */
| Decl_element Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

/* Note that the lexers again cannot recognize keywords such as EMPTY or
 * ANY because these identifiers are only keywords if they occur at special
 * positions.
 */

contentspec():
  /* parses a content model and returns it (type content_model_type) */
  /* WS */
  name: Name   /* EMPTY or ANY */
    {{ match name with
	  "EMPTY" -> Empty
	| "ANY"   -> Any
	| _       -> raise(WF_error("EMPTY, ANY, or a subexpression expected"))
    }}
| entid:Lparen  Ignore*  term:mixed_or_regexp(entid)
    {{ term }}


mixed_or_regexp(lparen_entid):
  /* WS */
  re: choice_or_seq(lparen_entid)
    {{ Regexp re }}
| m: mixed(lparen_entid)
    {{ m }}


multiplier():
  /* returns one of the multiplier symbols (?,*,+) */
  /* WS */
  Plus
    {{ Plus }}
| Star
    {{ Star }}
| Qmark
    {{ Qmark }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}


mixed (lparen_entid) :
  /* WS */
                   Pcdata 
                   Ignore*
  material:        mixed_alternatives_top()
    {{ 
      let rest, rparen_entid = material in
      if lparen_entid != rparen_entid then
	raise (Validation_error "Entities not properly nested with parentheses");
      Mixed (MPCDATA :: rest)
    }}


mixed_alternatives_top():
  /* WS */
  entid: Rparen
    {{ [], entid }}
| entid: RparenStar
    {{ [], entid }}
| Bar Ignore* name:Name Ignore* names:mixed_alternative()* entid:RparenStar
    {{ 
       (MChild name :: names), entid
    }}


mixed_alternative() :
  /* WS */
  Bar Ignore* name:Name Ignore*
    {{ MChild name }}


choice_or_seq (lparen_entid):
  /* parses either a regular expression, or a mixed expression. Returns
   * Mixed spec or Regexp spec (content_model_type).
   * Which kind of expression (regexp or mixed) is being read is recognized
   * after the first subexpression has been parsed; the other subexpressions
   * must be of the same kind.
   */
  /* WS */
  re:     cp() 
          Ignore*
  factor: choice_or_seq_factor()
    {{
      let (finalmark,subexpr), rparen_entid = factor in
      if lparen_entid != rparen_entid then
	raise (Validation_error "Entities not properly nested with parentheses");
      (* Check that the other subexpressions are "regexp", too, and
       * merge them with the first.
       *)
      let re' =
	match subexpr with
	    Alt []  ->  re
	  | Alt alt -> Alt (re :: alt)
	  | Seq seq -> Seq (re :: seq)
	  | _       -> assert false
      in
      (* Interpret the finalmark. *)
      match finalmark with
	  Ignore -> re'
	| Plus   -> Repeated1 re'
	| Star   -> Repeated re'
	| Qmark  -> Optional re'
	| _      -> assert false
    }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

choice_or_seq_factor():
  /* Parses "|<subexpr>|...)" or ",<subexpr>,...)", both forms optionally
   * followed by ?, *, or +.
   * Returns ((finalmark, expr), rparen_entid), where
   * - finalmark is the character after the right parenthesis or Ignore
   * - expr is either
   *   Alt []              meaning that only ")" has been found
   *   Alt non_empty_list  meaning that the subexpressions are separated by '|'
   *   Seq non_empty_list  meaning that the subexpressions are separated by ','
   */
  /* WS */
  entid:Rparen
    {{ (Ignore, Alt []), entid }}
| entid:RparenPlus
    {{ (Plus, Alt []), entid }}
| entid:RparenStar
    {{ (Star, Alt []), entid }}
| entid:RparenQmark
    {{ (Qmark, Alt []), entid }}
| Bar Ignore* re:cp() Ignore* factor:choice_or_seq_factor()
    {{ 
      let (finalmark, subexpr), rparen_entid = factor in
      begin match subexpr with
	  Alt []  -> (finalmark, (Alt [re])), rparen_entid
	| Alt alt -> (finalmark, (Alt (re :: alt))), rparen_entid
	| _       -> raise(WF_error("It is not allowed to mix alternatives and sequences"))
      end
    }}
| Comma Ignore* re:cp() Ignore* factor:choice_or_seq_factor()
    {{
      let (finalmark, subexpr), rparen_entid = factor in
      begin match subexpr with
	  Alt []  -> (finalmark, (Seq [re])), rparen_entid
	| Seq seq -> (finalmark, (Seq (re :: seq))), rparen_entid
	| _       -> raise(WF_error("It is not allowed to mix alternatives and sequences"))
      end
    }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

cp():
  /* parse either a name, or a parenthesized subexpression "(...)"  */
  /* WS */
  name:Name  m:multiplier()?
    {{ match m with
	  None       -> Child name
	| Some Plus  -> Repeated1 (Child name)
	| Some Star  -> Repeated  (Child name)
	| Some Qmark -> Optional  (Child name)
	| _          -> assert false
    }}
| entid:Lparen Ignore* m:choice_or_seq(entid)
    {{ m }}


/********************* ATTRIBUTE LIST DECLARATION ***********************/

attlistdecl():
  /* parses <!ATTLIST ... >. Enters the attribute list in dtd as side-
   * effect.
   */
  /* WS */
  decl_attlist_entid: Decl_attlist 
  $ {{ let extdecl = context.manager # current_entity_counts_as_external in
    }}
                      Ignore Ignore*
  el_name:            Name 
  ws:                 Ignore? Ignore*
  factor:             attdef_factor()
    {{ 
      let at_list, decl_rangle_entid = factor in

      if decl_attlist_entid != decl_rangle_entid then
	raise (Validation_error "Entities not properly nested with ATTLIST declaration");

      if not ws && at_list <> [] then begin
	match at_list with
	    (name,_,_) :: _ ->
	      (* This is normally impossible, because the lexer demands 
	       * some other token between two names.
	       *)
	      raise(WF_error("Missing whitespace before `" ^ name ^ "'"));
	  | _ -> assert false
      end;

      if extend_dtd then begin
	let new_el = new dtd_element dtd el_name in
	(* Note that it is allowed that <!ATTLIST...> precedes the corresponding
	 * <!ELEMENT...> declaration. In this case we add the element declaration
	 * already to the DTD but leave the content model unspecified.
	 *)
	let el =
	  try
	    dtd # add_element new_el;
	    new_el
	  with
	      Not_found ->  (* already added *)
		let old_el = dtd # element el_name in
		if old_el # attribute_names <>  [] then
		  config.warner # warn ("More than one ATTLIST declaration for element type `" ^
					el_name ^ "'");
		old_el
	in
	List.iter
	  (fun (a_name, a_type, a_default) ->
	     el # add_attribute a_name a_type a_default extdecl)
	  at_list
      end
    }}

/* M2Y: TODO: */
| Decl_attlist Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

attdef_factor():
  /* parses a list of triples <name> <type> <default value> and returns the
   * list as (string * att_type * att_default) list.
   */
  /* WS */
  attdef:attdef()   ws:Ignore?   Ignore*   factor:attdef_factor()
    {{ 
      let attdef_rest, decl_rangle_entid = factor in
      if not ws && attdef_rest <> [] then begin
	match attdef_rest with
	    (name,_,_) :: _ ->
	      raise(WF_error("Missing whitespace before `" ^ name ^ "'"));
	  | _ -> assert false
      end;
      (attdef :: attdef_rest), decl_rangle_entid }}
| entid:Decl_rangle
    {{ [], entid }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

attdef():
  /* Parses a single triple */
  /* WS */
  name:     Name 
            Ignore Ignore*
  tp:       atttype() 
            Ignore Ignore*
  default:  defaultdecl()
    {{ (name,tp,default) }}

/* In 'atttype' we again must recognize keywords. Again this is possible:
 * NOTATION is followed by a left parenthesis, and can be recognized by
 * the parser. The other keywords are grammatically equivalent (they do
 * not introduce their own phrases).
 * An enumeration can be recognized by a single left parenthesis. Note that
 * the lexer returns "nmtokens" that match the rules for "names" as Name,
 * not Nametoken.
 *
 * Note: The XML specification does not require that the entities are properly
 * nested with the parantheses of an attribute declaration.
 */


atttype():
  /* Parses an attribute type and returns it as att_type. */
  /* WS */
  name:      Name 
  $ {{ let followup = 
	 if name = "NOTATION" then 
	   parse_notation
	 else
	   parse_never
       in
     }}
  nota:      [followup]()?
    {{ 
       match name with
	  "CDATA"    -> A_cdata
	| "ID"       -> A_id
	| "IDREF"    -> A_idref
	| "IDREFS"   -> A_idrefs
	| "ENTITY"   -> A_entity
	| "ENTITIES" -> A_entities
	| "NMTOKEN"  -> A_nmtoken
	| "NMTOKENS" -> A_nmtokens
	| "NOTATION" ->
	    (match nota with
		 None   -> raise(WF_error("NOTATION type is incomplete"))
	       | Some n -> n
            )
	| _          -> raise(WF_error("One of CDATA, ID, IDREF, IDREFS, ENTITY, ENTITIES, NMTOKEN, NMTOKENS, NOTATION, or a subexpression expected"))
    }}

|         Lparen 
          Ignore* 
  name:   name_or_nametoken() 
          Ignore* 
  names:  nmtoken_factor()* 
          Rparen
    /* Enumeration */
    {{ A_enum(name :: names) }}

| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}


never():
  /* The always failing rule */
  /* WS */
  $ {{ raise Not_found; }}
  Doctype   /* questionable */
    {{ A_cdata    (* Does not matter *)
    }}


notation():
         Ignore Ignore*
         Lparen 
         Ignore*
  name:  Name 
         Ignore* 
  names: notation_factor()* 
         Rparen
  /* WS */
    {{ A_notation(name :: names) }}


notation_factor():
  /* Parse "|<name>" and return the name */
  /* WS */
  Bar Ignore* name:Name Ignore*
    {{ name }}


nmtoken_factor():
  /* Parse "|<nmtoken>" and return the nmtoken */
  /* WS */
  Bar Ignore* n:name_or_nametoken() Ignore*
    {{ n }}


name_or_nametoken():
  /* WS */
  n:Name      {{ n }}
| n:Nametoken {{ n }}


/* The default values must be expanded and normalized. This has been implemented
 * by the function expand_attvalue.
 */


defaultdecl():
  /* Parse the default value for an attribute and return it as att_default */
  /* WS */
  Required
    {{ D_required }}
| Implied
    {{ D_implied }}
| Fixed Ignore Ignore* str:Unparsed_string
    {{ D_fixed (expand_attvalue lexerset dtd str config.warner false) }}
| str:Unparsed_string
    {{ D_default (expand_attvalue lexerset dtd str config.warner false) }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}


/**************************** ENTITY DECLARATION ***********************/

entitydecl(decl_entity_entid):
  /* parses <!ENTITY ... >. The parsed entity declaration is entered into the
   * dtd object as side-effect.
   */
  /* WS */
  name:               Name 
  $ {{ let extdecl = context.manager # current_entity_counts_as_external in
    }}
                      Ignore Ignore* 
  material:           entitydef() 
                      Ignore*
  decl_rangle_entid:  Decl_rangle     
    /* A general entity */
    {{
       if decl_entity_entid != decl_rangle_entid then
	 raise (Validation_error "Entities not properly nested with ENTITY declaration");
      let en =
	(* Distinguish between
         * - internal entities
         * - external entities
         * - NDATA (unparsed) entities
         *)
	match material with
	    (Some s, None,     None)   ->
	      new internal_entity dtd name config.warner s p_internal_subset
		  config.errors_with_line_numbers false config.encoding
	  | (None,   Some xid, None)   ->
	      new external_entity (resolver # clone) dtd name config.warner
                                  xid false config.errors_with_line_numbers
		                  config.encoding

	  | (None,   Some xid, Some n) ->
	      (new ndata_entity name xid n config.encoding :> entity)
	  | _ -> assert false
      in
      dtd # add_gen_entity en extdecl
    }}

|                     Percent 
  $ {{ let extdecl = context.manager # current_entity_counts_as_external in
    }}
                      Ignore Ignore* 
  name:               Name 
                      Ignore Ignore* 
  material:           pedef() 
                      Ignore* 
  decl_rangle_entid:  Decl_rangle
    /* A parameter entity */
    {{ 
      if decl_entity_entid != decl_rangle_entid then
	 raise (Validation_error "Entities not properly nested with ENTITY declaration");
      let en =
	(* Distinguish between internal and external entities *)
	match material with
	    (Some s, None)   ->
	      new internal_entity dtd name config.warner s p_internal_subset
  		  config.errors_with_line_numbers true config.encoding
	  | (None,   Some xid)   ->
	      new external_entity (resolver # clone) dtd name config.warner
                                  xid true config.errors_with_line_numbers
		                  config.encoding
	  | _ -> assert false
      in

      (* The following two lines force that even internal entities count
       * as external (for the standalone check) if the declaration of 
       * the internal entity occurs in an external entity.
       *)
      if extdecl then
	en # set_counts_as_external;

      dtd # add_par_entity en;
    }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}


entitydef():
  /* parses the definition value of a general entity. Returns either:
   * - (Some s, None,   None)    meaning the definition of an internal entity
   *                               with (literal) value s has been found
   * - (None,   Some x, None)    meaning that an external parsed entity with
   *                               external ID x has been found
   * - (None,   Some x, Some n)  meaning that an unparsed entity with
   *                               external ID x and notations n has been found
   */
  /* WS */
  str:Unparsed_string
    {{ Some str, None, None }}
| id:external_id()   ws:Ignore?  Ignore*  decl:ndatadecl()?
    {{  if not ws  && decl <> None then
	  raise(WF_error("Whitespace missing before `NDATA'"));
	None, Some id, decl 
    }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

pedef():
  /* parses the definition value of a parameter entity. Returns either:
   * - (Some s, None)     meaning that the definition of an internal entity
   *                        with (literal) value s has been found
   * - (None,   Some x)   meaning that an external ID x has been found
   */
  /* WS */
  str:Unparsed_string
    {{ Some str, None }}
| id:external_id()
    {{ None, Some id }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}

ndatadecl():
  /* Parses either NDATA "string" or the empty string; returns Some "string"
   * in the former, None in the latter case.
   */
  /* WS */
  ndata:Name Ignore Ignore* name:Name
    {{ if ndata = "NDATA" then
	name
      else
	raise(WF_error("NDATA expected"))
    }}
| Begin_entity
    {{ raise (Validation_error("This entity reference is not allowed here")) }}


/**************************** NOTATION DECLARATION *******************/

notationdecl():
  /* parses <!NOTATION ... > and enters the notation declaration into the
   * dtd object as side-effect
   */
  /* WS */
  decl_notation_entid: Decl_notation 
                       Ignore Ignore*
  name:                Name 
                       Ignore Ignore*
  sys_or_public:       Name /* SYSTEM or PUBLIC */ 
                       Ignore Ignore*
  str1:                Unparsed_string 
  ws:                  Ignore? Ignore*
  str2:                Unparsed_string? 
                       Ignore*
  decl_rangle_entid:   Decl_rangle
    {{ 
      if decl_notation_entid != decl_rangle_entid then
	raise (Validation_error "Entities not properly nested with NOTATION declaration");
      let xid =
	(* Note that it is allowed that PUBLIC is only followed by one
	 * string literal
	 *)
	match sys_or_public with
	    "SYSTEM" ->
	      if str2 <> None then raise(WF_error("SYSTEM must be followed only by one argument"));
	      System str1
	  | "PUBLIC" ->
	      begin match str2 with
		  None ->
		    check_public_id str1;
		    Public(str1,"")
		| Some p ->
		    if not ws then
		      raise(WF_error("Missing whitespace between the string literals of the `PUBLIC' id"));
		    check_public_id str1;
		    Public(str1,p)
	      end
	  | _ -> raise(WF_error("One of PUBLIC or SYSTEM expected"))
      in
      if extend_dtd then begin
	let no = new dtd_notation name xid in
	dtd # add_notation no
      end
    }}

/****************************** ELEMENTS **************************/


contents_start():
  /* parses <element>...</element> misc*, i.e. exactly one element followed
   * optionally by white space or processing instructions.
   * The element is entered into the global variables as follows:
   * - If elstack is non-empty, the parsed element is added as new child to
   *   the top element of the stack.
   * - If elstack is empty, the root_examplar object is modified rather than
   *   that a new element is created. If additionally the variable root is
   *   None, it is assigned Some root_examplar.
   * Note that the modification of the root_exemplar is done by the method
   * internal_init.
   * The reason why the root element is modified rather than newly created
   * is a typing requirement. It must be possible that the class of the root
   * is derived from the original class element_impl, i.e. the user must be
   * able to add additional methods. If we created a new root object, we
   * would have to denote to which class the new object belongs; the root
   * would always be an 'element_impl' object (and not a derived object).
   * If we instead cloned an  exemplar object and modified it by the
   * "create" method, the root object would belong to the same class as the
   * exemplar (good), but the type of the parsing function would always
   * state that an 'element_impl' was created (because we can pass the new
   * object only back via a global variable). The only solution is to
   * modify the object that has been passed to the parsing function directly.
   */
  /* WS */
  start_tag() content()*
    {{ () }}


content():
  /* parses: start tags, end tags, content, or processing
   * instructions. That the tags are properly nested is dynamically checked.
   * As result, recognized elements are added to their parent elements,
   * content is added to the element containing it, and processing instructions
   * are entered into the element embracing them. (All as side-effects.)
   */
  /* WS */
  start_tag()
    {{ () }}
| end_tag()
    {{ () }}
| char_data()
    {{ () }}
| cref()
    {{ () }}
| pi()
    {{ () }}
| entity_ref()
    {{ () }}
| Comment
    {{ () }}


entity_ref():
  /* WS */
   Begin_entity eref_xmldecl_then_rest()
    {{ if n_tags_open = 0 then
	raise(WF_error("Entity reference not allowed here"))
    }}


/* See comment for doc_mldecl_then_misc_then_prolog_then_rest. */

eref_xmldecl_then_rest():
  /* WS */
  pl:PI_xml
  $ {{ context.manager # current_entity # process_xmldecl pl; 
    }}
  content()* End_entity
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  content() content()* End_entity
    {{ () }}

| $ {{ context.manager # current_entity # process_missing_xmldecl; }}
  End_entity
    {{ () }}


start_tag():
  /* parses <element attribute-values> or <element attribute-values/>.
   *
   * EFFECT: If elstack is non-empty, the element is added to the
   * top element of the stack as new child, and the element
   * is pushed on the stack. If elstack is empty, the root_exemplar is
   * modified and gets the parsed name and attribute list. The root_exemplar
   * is pushed on the stack. If additionally the variable root is empty, too,
   * this variable is initialized.
   * If the <element ... /> form has been parsed, no element is pushed
   * on the stack.
   */
  /* WS */
  tag:        Tag_beg
  ws:         Ignore? Ignore*
  attlist:    attribute()* 
  emptiness:  start_tag_rangle()
  /* Note: it is guaranteed that there is whitespace between Tag_beg and
   * the name of the first attribute, because there must be some separator.
   * So we need not to check ws!
   */
    {{ 
      let rec check_attlist al =
	match al with
	    (nv1, num1) :: al' ->
	      if not num1 && al' <> [] then begin
		match al with
		    ((n1,_),_) :: ((n2,_),_) :: _ ->
		      raise(WF_error("Whitespace is missing between attributes `" ^
				     n1 ^ "' and `" ^ n2 ^ "'"))
		  | _ -> assert false
	      end;
	      check_attlist al'
	  | [] -> ()
      in
      check_attlist attlist;
		
      let name, tag_beg_entid = tag in
      let attlist' = List.map (fun (nv,_) -> nv) attlist in
      let exemplar =
	try Hashtbl.find dom.map (T_element name)
	with Not_found -> dom.default_element in
      let d =
	exemplar # create_element dtd (T_element name) attlist' in

      if n_tags_open = 0 then begin
	if root = None then begin
	  (* We have found the begin tag of the root element. *)
	  if config.virtual_root then begin
	    (* The user wants the virtual root instead of the real root.
	     * The real root element becomes the child of the VR.
	     *)
	    (* Assertion: self # current is the virtual root *)
	    root <- Some (self # current);
	    self # current # add_node d;
	    doc # init_root (self # current);
	  end
	  else begin
	    (* Normal behaviour: The user wants to get the real root. *)
	    root <- Some d;
	    doc # init_root d;
	  end;
	end
	else
	  (* We have found a second topmost element. This is illegal. *)
	  raise(WF_error("Document must consist of only one toplevel element"))
      end
      else begin
	(* We have found some inner begin tag. *)
	self # current # add_node d
      end;

      if emptiness then
	(* An empty tag like <a/>. *)
	d # local_validate
      else begin
	(* A non-empty tag. *)
	Stack.push (d, tag_beg_entid) elstack;
	n_tags_open <- n_tags_open + 1;
      end;

    }}


attribute():
  /* Parses name="value" 
   * Returns a pair (empty, list):
   * - empty is a boolean and true iff the list is ended by "/>"
   * - list is the list of (name,value) pairs (both strings); the values
   *   are already expanded
   */
  /* WS */
  n:Name Ignore* Eq Ignore* v:attval() ws:Ignore? Ignore*
    {{ (n,v), ws }}


attval():
  /* WS */
  v:Attval
    {{ expand_attvalue lexerset dtd v config.warner true }}
| v:Attval_nl_normalized
    {{ expand_attvalue lexerset dtd v config.warner false }}


start_tag_rangle():
  /* WS */
  Rangle       {{ false }}
| Rangle_empty {{ true }}


end_tag():
  /* parses </element>.
   * Pops the top element from the elstack and checks if it is the same
   * element.
   */
  /* WS */
  tag:Tag_end  Ignore*  Rangle
    {{ let name, tag_end_entid = tag in
      if n_tags_open = 0 then
	raise(WF_error("End-tag without start-tag"));
      let x, tag_beg_entid = Stack.pop elstack in
      let x_name =
	match x # node_type with
	    T_data -> assert false
	  | T_element n -> n
      in
      if name <> x_name then
	raise(WF_error("End-tag does not match start-tag"));
      if tag_beg_entid != tag_end_entid then
	raise(WF_error("End-tag not in the same entity as the start-tag"));
      x # local_validate;

      n_tags_open <- n_tags_open - 1;
      
      assert (n_tags_open >= 0);

    }}

char_data():
  /* Parses any literal characters not otherwise matching, and adds the
   * characters to the top element of elstack.
   * If elstack is empty, it is assumed that there is no surrounding
   * element, and any non-white space character is forbidden.
   */
  /* WS */
  data:CharData
    {{ 
      if n_tags_open = 0 then
	(* only white space is allowed *)
	self # only_whitespace data
      else
	self # current # add_node (data_exemplar # create_data dtd data)
    }}
| data:Cdata
    {{ 
      if n_tags_open = 0 then
	raise (WF_error("CDATA section not allowed here"));
      self # current # add_node (data_exemplar # create_data dtd data)
    }}

cref():
  /* Parses &#...; and adds the character to the top element of elstack. */
  code:CRef
    {{ 
      if n_tags_open = 0 then
	(* No surrounding element: character references are not allowed *)
	raise(WF_error("Character reference not allowed here"));
      self # current # add_node
	                 (data_exemplar # create_data
	                 dtd
	                 (character config.encoding config.warner code))
    }}

pi():
  /* Parses <?...?> (but not <?xml white-space ... ?>).
   * If there is a top element in elstack, the processing instruction is added
   * to this element.
   */
  /* WS */
  pi: PI
    {{ let target,value = pi in
      if n_tags_open = 0 & not config.virtual_root
      then
	doc # add_pinstr (new proc_instruction target value)
      else begin
	(* Special case: if processing instructions are processed inline,
	 * they are wrapped into artificial "-pi" objects.
	 *)
	if config.processing_instructions_inline then begin
	  (* Get the 'exemplar', as usual: *)
	  let exemplar =
	    try Hashtbl.find dom.map (T_element "-pi")
	    with Not_found -> dom.default_element in
	  (* A trick: while the 'wrapper' is being created, the DTD is
	   * changed such that this is allowed.
	   *)
	  let aa = dtd # arbitrary_allowed in        (* save old state    *)
	  dtd # allow_arbitrary;
	  let wrapper =
	    exemplar # create_element dtd (T_element "-pi") [] in
	  if not aa then dtd # disallow_arbitrary;   (* restore old state *)
	  (* Put the PI into the 'wrapper' *)
	  wrapper # add_pinstr (new proc_instruction target value);
	  wrapper # local_validate;                  (* succeeds always   *)
	  self # current # add_node wrapper;
	  (* Note that a change in the function validate_content ensures
	   * that the parser does not complain about the additional elements
	   * in 'cur'
	   *)
	end
	else
	  (* Normal behaviour: Add the PI to the parent element. *)
	  self # current # add_pinstr (new proc_instruction target value)
      end
    }}


%%

   try
     match start_symbol with
	 Ext_document ->
	   parse_ext_document context.current context.get_next 
       | Ext_declarations ->
	   parse_ext_declarations context.current context.get_next 
       | Ext_element ->
	   parse_ext_element context.current context.get_next
   with
       Not_found ->
	 raise Parsing.Parse_error


(**********************************************************************)

(* Here ends the class definition: *)
end
;;

(**********************************************************************)

open Pxp_reader;;


class default_ext =
  object(self)
    val mutable node = (None : ('a extension node as 'a) option)
    method clone = {< >}
    method node =
      match node with
	  None ->
	    assert false
	| Some n -> n
    method set_node n =
      node <- Some n
  end
;;


let default_extension = new default_ext;;

let default_dom =
  let d = Hashtbl.create 2 in
  Hashtbl.add d T_data (new data_impl default_extension "");
  { map = d;
    default_element = new element_impl default_extension
  }
;;

let parse_dtd_entity cfg src =
  (* Parse a DTD given as separate entity. *)
  let dtd = new dtd cfg.warner cfg.encoding in
  let w = cfg.warner in
  let e = cfg.errors_with_line_numbers in
  let r, en =
    match src with
	Entity(m,r') -> r', m dtd
      | Channel ch -> let r = new resolve_read_channel ch w cfg.encoding in
	              r,
		      new external_entity r dtd "[toplevel dtd]" w (System "")
			                  false e cfg.encoding
      | File fname -> let r = new resolve_as_file w cfg.encoding in
	              r,
		      new external_entity r dtd "[toplevel dtd]" w (System fname)
                                          false e cfg.encoding
      | Latin1 str -> let r = new resolve_read_string str cfg.encoding in
	              r,
		      new external_entity r dtd "[toplevel dtd]" w (System "")
                                          false e cfg.encoding
      | ExtID(xid,r') -> 
  	              let r = r' # clone in
		      r, 
                      new external_entity r dtd "[toplevel dtd]" w xid false e
                                          cfg.encoding
  in
  en # set_debugging_mode (cfg.debugging_mode);
  let pobj =
    new parser_object
      (new document cfg.warner)
      dtd
      true
      cfg
      r
      default_dom
      false
  in
  let mgr = new entity_manager en in
  try
    en # open_entity true Declaration;
    let context = make_context mgr in
    pobj # parse context Ext_declarations;
    ignore(en # close_entity);
    dtd # validate;
    dtd
  with
      error ->
	ignore(en # close_entity);
	let pos = mgr # position_string in
	raise (At(pos, error))
;;


let parse_content_entity cfg src a_dtd dom_exempl =
  (* Parse an element given as separate entity *)
  a_dtd # validate;            (* ensure that the DTD is valid *)
  let w = cfg.warner in
  let e = cfg.errors_with_line_numbers in
  let r, en =
    match src with
	Entity(m,r') -> r', m a_dtd
      | Channel ch -> let r = new resolve_read_channel ch w cfg.encoding in
	              r,
		      new external_entity r a_dtd "[toplevel element]" w
			                  (System "") false e cfg.encoding
      | File fname -> let r = new resolve_as_file w cfg.encoding in
	              r,
		      new external_entity r a_dtd "[toplevel element]" w
			                  (System fname) false e cfg.encoding
      | Latin1 str -> let r = new resolve_read_string str cfg.encoding in
	              r,
		      new external_entity r a_dtd "[toplevel element]" w
			                  (System "") false e cfg.encoding
      | ExtID(xid,r') -> 
  	              let r = r' # clone in
		      r, 
		      new external_entity r a_dtd "[toplevel element]" w xid
                                          false e cfg.encoding
  in
  en # set_debugging_mode (cfg.debugging_mode);
  let pobj =
    new parser_object
      (new document cfg.warner)
      a_dtd
      true
      cfg 
      r
      dom_exempl
      false
  in
  let mgr = new entity_manager en in
  try
    en # open_entity true Content;
    let context = make_context mgr in
    pobj # parse context Ext_element;
    ignore(en # close_entity);
    match pobj # root with
	Some r -> r
      | None -> raise(WF_error("No root element"))
  with
      error ->
	ignore(en # close_entity);
	let pos = mgr # position_string in
	raise (At(pos, error))
;;


let iparse_document_entity cfg0 src dom_exempl p_wf =
  (* Parse an element given as separate entity *)
  let cfg = { cfg0 with
		recognize_standalone_declaration = 
                   cfg0.recognize_standalone_declaration && (not p_wf) 
            } in
  let a_dtd = new dtd cfg.warner cfg.encoding in
  let e = cfg.errors_with_line_numbers in
  if p_wf then
    a_dtd # allow_arbitrary;
  let a_doc = new document cfg.warner in
  let w = cfg.warner in
  let r, en =
    match src with
	Entity(m,r') -> r', m a_dtd
      | Channel ch -> let r = new resolve_read_channel ch w cfg.encoding in
	              r,
		      new document_entity r a_dtd "[toplevel document]" w (System "") e cfg.encoding
      | File fname -> let r = new resolve_as_file w cfg.encoding in
	              r,
		      new document_entity r a_dtd "[toplevel document]" w (System fname) e cfg.encoding
      | Latin1 str -> let r = new resolve_read_string str cfg.encoding in
	              r,
		      new document_entity r a_dtd "[toplevel document]" w (System "") e cfg.encoding
      | ExtID(xid,r') ->
  	              let r = r' # clone in
		      r, 
		      new document_entity r a_dtd "[toplevel document]" w xid e
                                          cfg.encoding
  in
  en # set_debugging_mode (cfg.debugging_mode);
  let pobj =
    new parser_object
      a_doc
      a_dtd
      (not p_wf)
      cfg 
      r
      dom_exempl
      true          (* TODO: change to 'not p_wf' ? *)
  in
  let mgr = new entity_manager en in
  try
    en # open_entity true Document;          (* open the entity *)
    let context = make_context mgr in
    pobj # parse context Ext_document;
    let d = pobj # doc in                    (* get the parsed document *)
    ignore(en # close_entity);               (* close the entity *)
    (* return the document to the caller *)
    d
  with
      error ->
	ignore(en # close_entity);
	let pos = mgr # position_string in
	raise (At(pos, error))
;;


let parse_document_entity cfg src dom_exempl =
  iparse_document_entity cfg src dom_exempl false;;
let parse_wf_entity cfg src dom_exempl =
  iparse_document_entity cfg src dom_exempl true;;


let default_config =
  let w = new collect_warnings in
  { warner = w;
    errors_with_line_numbers = true;
    processing_instructions_inline = false;
    virtual_root = false;
    encoding = `Enc_iso88591;
    recognize_standalone_declaration = true;
    debugging_mode = false;
  }


(* ======================================================================
 * History:
 *
 * $Log: pxp_yacc.m2y,v $
 * Revision 1.1  2000/05/29 23:48:38  gerd
 * 	Changed module names:
 * 		Markup_aux          into Pxp_aux
 * 		Markup_codewriter   into Pxp_codewriter
 * 		Markup_document     into Pxp_document
 * 		Markup_dtd          into Pxp_dtd
 * 		Markup_entity       into Pxp_entity
 * 		Markup_lexer_types  into Pxp_lexer_types
 * 		Markup_reader       into Pxp_reader
 * 		Markup_types        into Pxp_types
 * 		Markup_yacc         into Pxp_yacc
 * See directory "compatibility" for (almost) compatible wrappers emulating
 * Markup_document, Markup_dtd, Markup_reader, Markup_types, and Markup_yacc.
 *
 * ======================================================================
 * Old logs from markup_yacc.m2y:
 *
 * Revision 1.9  2000/05/29 21:14:57  gerd
 * 	Changed the type 'encoding' into a polymorphic variant.
 *
 * Revision 1.8  2000/05/27 19:26:19  gerd
 * 	Change: The XML declaration is interpreted right after
 * it has been parsed (no longer after the document): new function
 * check_and_parse_xmldecl.
 * 	When elements, attributes, and entities are declared
 * it is stored whether the declaration happens in an external
 * entity (for the standalone check).
 * 	The option recognize_standalone_declaration is interpreted.
 *
 * Revision 1.7  2000/05/20 20:31:40  gerd
 * 	Big change: Added support for various encodings of the
 * internal representation.
 *
 * Revision 1.6  2000/05/14 21:51:24  gerd
 * 	Change: Whitespace is handled by the grammar, and no longer
 * by the entity.
 *
 * Revision 1.5  2000/05/14 17:50:54  gerd
 * 	Updates because of changes in the token type.
 *
 * Revision 1.4  2000/05/11 22:09:17  gerd
 * 	Fixed the remaining problems with conditional sections.
 * This seems to be also a weakness of the XML spec!
 *
 * Revision 1.3  2000/05/09 00:02:44  gerd
 * 	Conditional sections are now recognized by the parser.
 * There seem some open questions; see the TODO comments!
 *
 * Revision 1.2  2000/05/08 22:01:44  gerd
 * 	Introduced entity managers (see markup_entity.ml).
 * 	The XML declaration is now recognized by the parser. If such
 * a declaration is found, the method process_xmldecl of the currently
 * active entity is called. If the first token is not an XML declaration,
 * the method process_missing_xmldecl is called instead.
 * 	Some minor changes.
 *
 * Revision 1.1  2000/05/06 23:21:49  gerd
 * 	Initial revision.
 *
 *	
 * ======================================================================
 *
 * COPIED FROM REVISION 1.19 OF markup_yacc.mly
 *
 * Revision 1.19  2000/05/01 15:20:08  gerd
 * 	"End tag matches start tag" is checked before "End tag in the
 * same entity as start tag".
 *
 * Revision 1.18  2000/04/30 18:23:08  gerd
 * 	Bigger change: Introduced the concept of virtual roots. First,
 * this reduces the number of checks. Second, it makes it possible to
 * return the virtual root to the caller instead of the real root (new
 * config options 'virtual_root' and 'processing_instructions_inline').
 * 	Minor changes because of better CR/CRLF handling.
 *
 * Revision 1.17  2000/03/13 23:47:46  gerd
 * 	Updated because of interface changes. (See markup_yacc_shadow.mli
 * rev. 1.8)
 *
 * Revision 1.16  2000/01/20 20:54:43  gerd
 * 	New config.errors_with_line_numbers.
 *
 * Revision 1.15  1999/12/17 22:27:58  gerd
 * 	Bugfix: The value of 'p_internal_subset' (an instance
 * variable of the parser object) is to true when the internal subset
 * begins, and is set to false when this subset ends. The error was
 * that references to external entities within this subset did not
 * set 'p_internal_subset' to false; this is now corrected by introducing
 * the 'p_internal_subset_stack'.
 * 	This is a typical example of how the code gets more and
 * more complicated and that it is very difficult to really understand
 * what is going on.
 *
 * Revision 1.14  1999/11/09 22:23:37  gerd
 * 	Removed the invocation of "init_dtd" of the root document.
 * This method is no longer available. The DTD is also passed to the
 * document object by the root element, so nothing essential changes.
 *
 * Revision 1.13  1999/10/25 23:37:09  gerd
 * 	Bugfix: The warning "More than one ATTLIST declaration for element
 * type ..." is only generated if an ATTLIST is found while there are already
 * attributes for the element.
 *
 * Revision 1.12  1999/09/01 23:08:38  gerd
 * 	New frontend function: parse_wf_document. This simply uses
 * a DTD that allows anything, and by the new parameter "extend_dtd" it is
 * avoided that element, attlist, and notation declarations are added to this
 * DTD. The idea is that this function simulates a well-formedness parser.
 * 	Tag_beg, Tag_end carry the entity_id. The "elstack" stores the
 * entity_id of the stacked tag. This was necessary because otherwise there
 * are some examples to produces incorrectly nested elements.
 * 	p_internal_subset is a variable that stores whether the internal
 * subset is being parsed. This is important beacause entity declarations in
 * internal subsets are not allowed to contain parameter references.
 * 	It is checked if the "elstack" is empty after all has been parsed.
 * 	Processing instructions outside DTDs and outside elements are now
 * added to the document.
 * 	The rules of mixed and regexp style content models have been
 * separated. The code is now much simpler.
 * 	Entity references outside elements are detected and rejected.
 *
 * Revision 1.11  1999/09/01 16:26:08  gerd
 * 	Improved the quality of error messages.
 *
 * Revision 1.10  1999/08/31 19:13:31  gerd
 * 	Added checks on proper PE nesting. The idea is that tokens such
 * as Decl_element and Decl_rangle carry an entity ID with them. This ID
 * is simply an object of type < >, i.e. you can only test on identity.
 * The lexer always produces tokens with a dummy ID because it does not
 * know which entity is the current one. The entity layer replaces the dummy
 * ID with the actual ID. The parser checks that the IDs of pairs such as
 * Decl_element and Decl_rangle are the same; otherwise a Validation_error
 * is produced.
 *
 * Revision 1.9  1999/08/15 20:42:01  gerd
 * 	Corrected a misleading message.
 *
 * Revision 1.8  1999/08/15 20:37:34  gerd
 * 	Improved error messages.
 * 	Bugfix: While parsing document entities, the subclass document_entity is
 * now used instead of external_entity. The rules in document entities are a bit
 * stronger.
 *
 * Revision 1.7  1999/08/15 14:03:59  gerd
 * 	Empty documents are not allowed.
 * 	"CDATA section not allowed here" is a WF_error, not a Validation_
 * error.
 *
 * Revision 1.6  1999/08/15 02:24:19  gerd
 * 	Removed some grammar rules that were used for testing.
 * 	Documents without DTD can now have arbitrary elements (formerly
 * they were not allowed to have any element).
 *
 * Revision 1.5  1999/08/14 22:57:20  gerd
 * 	It is allowed that external entities are empty because the
 * empty string is well-parsed for both declarations and contents. Empty
 * entities can be referenced anywhere because the references are replaced
 * by nothing. Because of this, the Begin_entity...End_entity brace is only
 * inserted if the entity is non-empty. (Otherwise references to empty
 * entities would not be allowed anywhere.)
 * 	As a consequence, the grammar has been changed such that a
 * single Eof is equivalent to Begin_entity,End_entity without content.
 *
 * Revision 1.4  1999/08/14 22:20:01  gerd
 *         The "config" slot has now a component "warner" which is
 * an object with a "warn" method. This is used to warn about characters
 * that cannot be represented in the Latin 1 alphabet.
 *         Furthermore, there is a new component "debugging_mode".
 *         Some Parse_error exceptions have been changed into Validation_error.
 *         The interfaces of functions/classes imported from other modules
 * have changed; the invocations have been adapted.
 *         Contents may contain CDATA sections that have been forgotten.
 *
 * Revision 1.3  1999/08/11 15:00:41  gerd
 * 	The Begin_entity ... End_entity brace is also possible in
 * 'contents'.
 * 	The configuration passed to the parsing object contains always
 * the resolver that is actually used.
 *
 * Revision 1.2  1999/08/10 21:35:12  gerd
 * 	The XML/encoding declaration at the beginning of entities is
 * evaluated. In particular, entities have now a method "xml_declaration"
 * which returns the name/value pairs of such a declaration. The "encoding"
 * setting is interpreted by the entity itself; "version", and "standalone"
 * are interpreted by Markup_yacc.parse_document_entity. Other settings
 * are ignored (this does not conform to the standard; the standard prescribes
 * that "version" MUST be given in the declaration of document; "standalone"
 * and "encoding" CAN be declared; no other settings are allowed).
 * 	TODO: The user should be warned if the standard is not exactly
 * fulfilled. -- The "standalone" property is not checked yet.
 *
 * Revision 1.1  1999/08/10 00:35:52  gerd
 * 	Initial revision.
 *
 *
 *)
